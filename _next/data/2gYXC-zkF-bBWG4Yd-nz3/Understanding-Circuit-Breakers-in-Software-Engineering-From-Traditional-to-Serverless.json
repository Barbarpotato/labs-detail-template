{"pageProps":{"article":{"blog_id":"86f7440f-033f-4459-b0a5-09f74d7c34ba","title":"Understanding Circuit Breakers in Software Engineering: From Traditional to Serverless","short_description":"Imagine you’re using electricity at home, and a short circuit occurs. The circuit breaker in your electrical panel cuts the power to prevent a fire. In software, the concept is similar: it’s a design pattern that protects your system from repeated failures when calling external services","description":"<h2>What Is a Circuit Breaker?</h2><p>Imagine you’re using electricity at home, and a short circuit occurs. The <em>circuit breaker</em> in your electrical panel cuts the power to prevent a fire. In software, the concept is similar: it’s a design pattern that protects your system from repeated failures when calling external services (APIs, databases, etc.).</p><h2>Main Purposes:</h2><h3><strong>Detect Failures</strong></h3><p>The first job of a <em>circuit breaker</em> is to act as a vigilant watchdog, constantly monitoring interactions between your application and external services like APIs, databases, or third-party systems. It keeps an eye on every request, tracking whether they succeed or fail based on specific criteria, such as receiving an error code (e.g., HTTP 500), timing out after a set duration (e.g., no response within 2 seconds), or encountering exceptions like network disconnections.</p><p>To do this effectively, the circuit breaker collects data over a defined window—perhaps the last 10 requests or the past 30 seconds—and calculates metrics like the total number of failures or the failure rate (e.g., 60% of calls failed). If these metrics cross a configurable threshold—say, five failures in a row or a 50% error rate—it recognizes that something’s wrong with the external service. This detection isn’t just about noticing a single hiccup; it’s about identifying patterns of unreliability that could harm your system if left unchecked. By catching these issues early, the circuit breaker ensures your application doesn’t blindly keep trying a service that’s clearly struggling.</p><h3><strong>Prevent Cascading Failures</strong></h3><p>Once a failure is detected, the circuit breaker steps in to stop a domino effect known as <em>cascading failures</em>, where one broken component drags down the entire system. Imagine an e-commerce app where the payment API is down: without a circuit breaker, every user request might hang, waiting for a timeout, piling up server resources, slowing the database, and eventually crashing the whole application.</p><p>In its Closed state, the circuit breaker allows calls to proceed, but as soon as failures hit the threshold, it flips to Open, cutting off all further attempts to contact the faulty service. This immediate halt prevents the problem from rippling through your system—your app stops wasting threads, memory, or CPU cycles on a hopeless task. Instead of letting a single point of failure—like a slow third-party API—overload your servers or exhaust connection pools, the circuit breaker isolates the issue, keeping the rest of your application stable and responsive. It’s like closing a floodgate to protect the town downstream from a burst dam.</p><h3><strong>Provide a Fallback Response</strong></h3><p>When the circuit breaker blocks calls in its Open state, it doesn’t just leave users hanging—it offers a fallback response to keep the system usable. This fallback is a preplanned alternative to the failed service’s output, designed to minimize disruption.</p><p>For example, if a weather API fails, the circuit breaker might return a cached forecast from an hour ago or a simple message like \"Weather data unavailable, try again later.\" In a payment system, it could redirect users to an alternative checkout method or log the attempt for later retry. The fallback doesn’t fix the root problem, but it ensures graceful degradation.</p><p>Your application keeps running in a limited capacity rather than crashing or showing cryptic errors. Crafting a good fallback requires understanding your use case: it might be static data, a default value, or even a call to a backup service. By providing this safety net, the circuit breaker maintains user trust and buys time for the external service to recover without sacrificing functionality entirely.</p><p><img src=\"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1741949039277_Circuit-Breaker-Pattern.jpg\" alt=\"Circuit Breaker Pattern\" width=\"720px\"></p><h2>Overall Mechanism</h2><ol><li><strong>Closed</strong>: All calls are forwarded. If failures exceed the threshold (e.g., 5), it switches to Open.</li><li><strong>Open</strong>: Calls are blocked, and a <em>fallback</em> is used. After a set time (e.g., 30 seconds), it moves to Half-Open.</li><li><strong>Half-Open</strong>: A test call is made. Success → Closed, Failure → Open.</li></ol><h3>Simple Code Example</h3><p>Here’s a basic implementation in JavaScript:</p><div><pre><code>class CircuitBreaker {\n&nbsp; constructor(maxFailures = 5, resetTimeout = 30000) {\n&nbsp; &nbsp; this.state = \"CLOSED\";\n&nbsp; &nbsp; this.failureCount = 0;\n&nbsp; &nbsp; this.maxFailures = maxFailures;\n&nbsp; &nbsp; this.resetTimeout = resetTimeout;\n&nbsp; }\n\n\n&nbsp; async call(service) {\n&nbsp; &nbsp; if (this.state === \"OPEN\") {\n&nbsp; &nbsp; &nbsp; if (Date.now() &gt; this.resetTime) {\n&nbsp; &nbsp; &nbsp; &nbsp; this.state = \"HALF_OPEN\";\n&nbsp; &nbsp; &nbsp; } else {\n&nbsp; &nbsp; &nbsp; &nbsp; return \"Fallback: Service unavailable\";\n&nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n\n\n&nbsp; &nbsp; try {\n&nbsp; &nbsp; &nbsp; const result = await service();\n&nbsp; &nbsp; &nbsp; if (this.state === \"HALF_OPEN\") {\n&nbsp; &nbsp; &nbsp; &nbsp; this.state = \"CLOSED\";\n&nbsp; &nbsp; &nbsp; &nbsp; this.failureCount = 0;\n&nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; return result;\n&nbsp; &nbsp; } catch (error) {\n&nbsp; &nbsp; &nbsp; this.failureCount++;\n&nbsp; &nbsp; &nbsp; if (this.failureCount &gt;= this.maxFailures) {\n&nbsp; &nbsp; &nbsp; &nbsp; this.state = \"OPEN\";\n&nbsp; &nbsp; &nbsp; &nbsp; this.resetTime = Date.now() + this.resetTimeout;\n&nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; return \"Fallback: Service unavailable\";\n&nbsp; &nbsp; }\n&nbsp; }\n}\n\n\n// Example usage\nconst breaker = new CircuitBreaker();\nconst fakeService = () =&gt; Math.random() &gt; 0.5 ? \"Success\" : Promise.reject(\"Error\");\nbreaker.call(fakeService).then(console.log);\n</code></pre></div><h2>Circuit Breakers in Serverless</h2><p>In a <em>serverless</em> environment (e.g., AWS Lambda), <em>circuit breakers</em> are still valuable, but their stateless nature poses challenges. The state must be stored externally, such as in DynamoDB.</p><h3>Example in AWS Lambda</h3><div><pre><code>const AWS = require('aws-sdk');\nconst dynamodb = new AWS.DynamoDB.DocumentClient();\n\n\nasync function handler(event) {\n&nbsp; const serviceName = \"ExternalAPI\";\n&nbsp; const state = await dynamodb.get({\n&nbsp; &nbsp; TableName: \"CircuitBreakerState\",\n&nbsp; &nbsp; Key: { Service: serviceName }\n&nbsp; }).promise();\n\n\n&nbsp; if (state.Item?.State === \"OPEN\" &amp;&amp; Date.now() &lt; state.Item.ResetTime) {\n&nbsp; &nbsp; return { statusCode: 503, body: \"Service unavailable\" };\n&nbsp; }\n\n\n&nbsp; try {\n&nbsp; &nbsp; const response = await callExternalAPI();\n&nbsp; &nbsp; if (state.Item?.State === \"HALF_OPEN\") {\n&nbsp; &nbsp; &nbsp; await dynamodb.update({\n&nbsp; &nbsp; &nbsp; &nbsp; TableName: \"CircuitBreakerState\",\n&nbsp; &nbsp; &nbsp; &nbsp; Key: { Service: serviceName },\n&nbsp; &nbsp; &nbsp; &nbsp; UpdateExpression: \"SET #state = :closed\",\n&nbsp; &nbsp; &nbsp; &nbsp; ExpressionAttributeNames: { \"#state\": \"State\" },\n&nbsp; &nbsp; &nbsp; &nbsp; ExpressionAttributeValues: { \":closed\": \"CLOSED\" }\n&nbsp; &nbsp; &nbsp; }).promise();\n&nbsp; &nbsp; }\n&nbsp; &nbsp; return { statusCode: 200, body: response };\n&nbsp; } catch (error) {\n&nbsp; &nbsp; // Logic to update failure count and switch to Open\n&nbsp; &nbsp; return { statusCode: 503, body: \"Service unavailable\" };\n&nbsp; }\n}\n</code></pre></div><h2>Conclusion</h2><p><em>Circuit breakers</em> are a powerful pattern for building resilient systems, whether on traditional servers or in <em>serverless</em> environments. With the simulations and code above, I hope you’ve gained a clearer understanding of how they work.</p>","timestamp":"Friday, March 14, 2025 at 10:46:27 AM GMT+8","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1741948558177_circuit_breaker.png","image_alt":"Circuit breaker","slug":"Understanding-Circuit-Breakers-in-Software-Engineering-From-Traditional-to-Serverless","index":"6b86b273ff34f","tags":["Software Architecture","System Design"]},"recommendedPosts":[{"blog_id":"36855ea7-b37b-4b4c-91f1-27d90b9bde59","title":"Understanding Database Partitioning vs Sharding: Concepts, Benefits, and Challenges","short_description":"When dealing with large volumes of data, efficient database management becomes essential. Two widely used techniques to improve performance and scalability are database partitioning and database sharding. Although often confused, these approaches differ fundamentally in architecture, complexity, and suitable use cases. This article explores these differences in detail, helping you decide which fits your application best.","timestamp":"2025-05-17 09:42:15","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1747474398774_partition%20vs%20sharding%20db.png","image_alt":"partition vs sharding Database","slug":"Understanding-Database-Partitioning-vs-Sharding-Concepts-Benefits-and-Challenges","index":"d4735e3a265e1","tags":["Database","Database Architecture","Software Architecture","System Design"]},{"blog_id":"675f800c-08cb-459f-aa7d-44cdc9c9c169","title":"System Design Simplified: The Trade-Off Triangle You Must Master","short_description":"Behind every well-architected system is a set of tough decisions. The CAP Theorem simplifies those decisions by showing you what you must give up to keep your system fast, correct, and resilient. Learn how to apply this in real-world architecture.","timestamp":"2025-05-13 01:58:48","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1747100859417_CAP%20BG.jpg","image_alt":"CAP background","slug":"System-Design-Simplified-The-Trade-Off-Triangle-You-Must-Master","index":"d4735e3a265e1","tags":["System Design","CAP Theorem","Distributed Systems"]},{"blog_id":"5c2626c4-8a10-47f1-8c5c-b3ac2d84b69a","title":"Why Domain-Driven Design (DDD) Matters: From Chaos to Clarity in Complex Systems","short_description":"Domain-Driven Design (DDD) is a powerful approach to software development that places the business domain—not the technology—at the center of your design decisions. First introduced by Eric Evans, DDD is essential for developers and architects who want to build systems that reflect real-world complexity and change.","timestamp":"2025-05-12 04:23:04","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1747022797381_Domain-Driven-Design_cover.jpg","image_alt":"DDD Cover","slug":"Why-Domain-Driven-Design-DDD-Matters-From-Chaos-to-Clarity-in-Complex-Systems","index":"d4735e3a265e1","tags":["DDD","Software Architecture","System Design"]}]},"__N_SSG":true}