{"pageProps":{"article":{"blog_id":"9c490813-d5d6-4e27-8cc8-31f115046c0e","title":"GraphQL Fundamental","short_description":"GraphQL is a powerful query language for your API, and it provides a more efficient, powerful, and flexible alternative to the traditional REST API.","description":"<div id=\"content-0\"><h1>What is GraphQL?</h1><p>GraphQL is a query language for your API, and it's designed to request and deliver exactly the data that a client needs. Unlike REST, where the server determines what data is returned, GraphQL puts the control in the hands of the client. This allows for more efficient data retrieval, reduces over-fetching and under-fetching, and enables clients to request multiple resources in a single query.</p><h1>How Does GraphQL Work?</h1><p>GraphQL is based on a strong schema that defines the types and operations available in your API. Clients can request data by specifying what they need, and the server responds with only the requested data in a structured format (typically JSON). The server resolves the query by matching it to the available types and fields in the schema.</p><h1>Setting Up GraphQL with Node.js, Express, and graphql-express</h1><p>This Content will guide you through the process of setting up a GraphQL server on the backend using Node.js, Express, and the graphql-express package. GraphQL is a powerful query language that allows you to request and deliver data with precision, and this setup will enable you to create a flexible API.</p><h1>Prerequisites</h1><p>Before you get started, ensure you have the following prerequisites:</p><ol><li>Node.js installed on your machine.</li><li>A basic understanding of JavaScript and Express.</li></ol><h1>Basic Installation &amp; Usage</h1></div><div id=\"content-2\"><ul><li>Create a New Node.js Project: If you don't already have a Node.js project, create a new directory for your project and run npm init to initialize a new Node.js project.</li></ul></div><div id=\"content-3\"><ul><li>Install Dependencies: You'll need to install the required packages using npm. Run the following command to install Express, GraphQL, and graphql-express:</li></ul></div><div id=\"content-4\"><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\">npm install express graphql express-graphql</code></pre></div><div id=\"content-5\"><ul><li>Create a Server File: Create a new JavaScript file (e.g., app.js) in your project directory.</li><li>Import Dependencies: In server.js, import the necessary packages and set up the Express app.</li></ul></div><div id=\"content-6\"><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\">const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\n\nconst app = express();</code></pre></div><div id=\"content-8\"><p>Create Schema Folder and create schema.js file. In Schema file there is some component that you need to understand:</p><h2><strong>Create GraphQL Object Type</strong></h2><p>Object Type is a fundamental building block used to define the structure of the data that can be queried from a GraphQL API. It represents a type of object that can be retrieved or manipulated through the API. Object Types play a crucial role in modeling the data and defining the shape of the response that clients can request. Below is the example of how to make Object Type of GraphQL:</p></div><div id=\"content-9\"><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\">const BookType = new GraphQLObjectType({\n    name: 'book',\n    fields: () =&gt; ({\n        id: { type: GraphQLString },\n        name: { type: GraphQLString },\n        genre: { type: GraphQLString }\n    })\n});</code></pre></div><div id=\"content-10\"><h2>Create Entry Point to the GraphQL Schema</h2><p>Query is an operation type in GraphQL used to read or retrieve data from the server. They are created using the RootQuery Object Type and include fields that can be accessed by clients. Below the example code:</p></div><div id=\"content-11\"><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\">const RootQuery = new GraphQLObjectType({\n    name: 'RootQueryType',\n    fields: {\n        book: {\n            type: BookType,\n            args: { id: { type: GraphQLString } },\n            resolve(parent, args) {\n                // code to get data from db\n                return books.filter(object =&gt; object.id === args.id)[0]\n            }\n        }\n    }\n});</code></pre></div><div id=\"content-13\"><p>This code is defining a RootQuery type in GraphQL, which serves as the entry point for querying data in the schema.</p><ol><li>const RootQuery = new GraphQLObjectType({ ... }): This line creates a new GraphQL Object Type called RootQuery. The RootQuery type is special in GraphQL, as it is the starting point for all read (query) operations. It defines the fields that clients can query from the root of the schema.</li><li>name: 'RootQueryType': This sets the name for the RootQueryType. In this case, it's named \"RootQueryType.\"</li><li>fields: { ... }: Here, you define the available fields within the RootQuery. Each field represents a possible query that clients can make.</li><li>book: { ... }: This defines a field called \"book\" within the RootQuery. Clients can use this field to query information about books.</li><li>type: BookType: The type field specifies the data type that will be returned by the \"book\" query. In this case, it's set to the BookType, indicating that when a client queries \"book,\" they will receive data structured according to the BookType.</li><li>args: { id: { type: GraphQLString } }: The args field specifies the arguments that can be provided with the \"book\" query. In this case, there's one argument named \"id,\" which is of type GraphQLString. It means that clients need to provide an \"id\" when querying for a book.</li><li>resolve(parent, args) { ... }: The resolve function is where you specify how to fetch the actual data when a client makes a query for \"book.\"</li><li>return books.filter(object =&gt; object.id === args.id)[0]: Within the resolve function, you see code to fetch the data. In this case, it's looking through an array called \"books\" to find a book with an \"id\" that matches the one provided by the client. The filter method is used to find the matching book, and [0] is added to return the first matching result. This result will be returned to the client in the shape of a BookType.</li></ol><p>Finally, the code exports a new GraphQLSchema instance with the RootQuery as the query root. This makes the book query available for use in your GraphQL API.</p></div><div id=\"content-14\"><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\">module.exports = new GraphQLSchema({\nquery: RootQuery\n});</code></pre></div><div id=\"content-15\"><ul><li>Set Up GraphQL Middleware to your app.js: Use the graphqlHTTP middleware to create a GraphQL endpoint for your Express app.</li></ul></div><div id=\"content-16\"><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\">app.use('/graphql', graphqlHTTP({\n    schema: schema,\n    graphiql: true\n}))</code></pre></div><div id=\"content-17\"><p>by using the graphiql property to your middleware, the backend service will provide the graphql development interface that can be access for demo and simulate accessing the different variant of our http request.</p></div><div id=\"content-18\"><ul><li>Start the Server: Start the Express server on a port of your choice.</li></ul></div><div id=\"content-19\"><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\">app.listen(4000, () =&gt; {\n    console.log(`Now Listening on Post 4000`)\n})</code></pre></div><div id=\"content-20\"><ul><li>Testing Your Queries in GrapiQL: You can access the /graphql endpoint in your browser, and the interface will be like this:</li></ul></div><div id=\"content-21\"><img src='https://github.com/Barbarpotato/GraphQL-Fundamental/raw/main/images/graphiql-example1.png'/></div><div id=\"content-22\"><h2>List Type</h2><p>So far we have already built the relationship between the book and who is the author from the book. Now we want to build the relationship between the author and the book. we want to know if some author are called trough the request, we want to know what books they are created. in other words we call it&nbsp;<code style=\"background-color: var(--bgColor-neutral-muted, var(--color-neutral-muted));\">one to many</code>&nbsp;relationship if we are on the relational database environment, which is one author can have many books they created. Below is the example of how to implement it in GraphQL:</p></div><div id=\"content-23\"><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\">// we added additional object for the one to many relationship display purposes.\nconst books = [\n    { name: 'Name of thw Wind', genre: 'Fantasy', id: '1', authorId: '1' },\n    { name: 'The Final Empire', genre: 'Fantasy', id: '2', authorId: '2' },\n    { name: 'The Long Earth', genre: 'Sci-Fi', id: '3', authorId: '3' },\n    { name: 'The Hero Of Ages', genre: 'Fantasy', id: '4', authorId: '2' },\n    { name: 'The Colourof Magic', genre: 'Fantasy', id: '5', authorId: '3' },\n    { name: 'The Loght Fantastic', genre: 'Fantasy', id: '6', authorId: '3' }\n];\n\nconst authors = [\n    { name: 'Patrick Bateman', age: 29, id: '1' },\n    { name: 'Bruce Wayne', age: 33, id: '2' },\n    { name: 'Peter Parker', age: 25, id: '3' }\n]\n\nconst AuthorType = new GraphQLObjectType({\n    name: 'author',\n    fields: () =&gt; ({\n        id: { type: GraphQLID },\n        name: { type: GraphQLString },\n        age: { type: GraphQLInt },\n        book: {\n            type: new GraphQLList(BookType),\n            resolve(parent, args) {\n                return books.filter(object =&gt; object.authorId === parent.id)\n            }\n        }\n    })\n});</code></pre></div><div id=\"content-24\"><ul><li>In above code, dont forget that we are going to return multiple object from the book fields, which we are need the&nbsp;<code style=\"background-color: var(--bgColor-neutral-muted, var(--color-neutral-muted));\">GraphQLList</code>&nbsp;imported from the&nbsp;<code style=\"background-color: var(--bgColor-neutral-muted, var(--color-neutral-muted));\">graphql</code>&nbsp;instance.</li><li>we are returning the processed data from the authorType. This data will be processed again in resolve function book field.</li><li>the result query if we success build this one to many relations:</li></ul></div><div id=\"content-25\"><img src='https://github.com/Barbarpotato/GraphQL-Fundamental/raw/main/images/type-list.png'/></div><div id=\"content-26\"><h2>All Objects</h2><p>For some cases, we need to return all list of books, or all list of author that we want to the client. To do this we just added some field in the&nbsp;<code style=\"background-color: var(--bgColor-neutral-muted, var(--color-neutral-muted));\">RootQuery</code>&nbsp;of our Schema:</p></div><div id=\"content-27\"><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\">const RootQuery = new GraphQLObjectType({\n    name: 'RootQueryType',\n    fields: {\n        ...,\n        ...,\n        books: {\n            type: new GraphQLList(BookType),\n            resolve(_parent, _args) {\n                return books\n            }\n        },\n        authors: {\n            type: new GraphQLList(AuthorType),\n            resolve(_parent, _args) {\n                return authors\n            }\n        }\n    }\n});</code></pre></div><div id=\"content-29\"><p>The result output from the graphiql will be like this:</p></div><div id=\"content-30\"><img src='https://github.com/Barbarpotato/GraphQL-Fundamental/raw/main/images/all-objects.png'/></div>","timestamp":"Friday, September 20, 2024 at 11:37:06 AM GMT+8","image":"https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2Fgraphql.png?alt=media&token=bdb93458-f903-44e3-bb96-0086a7f78a6e","image_alt":"Graph QL - Darma Labs","slug":"graphql-fundamental","index":"6b86b273ff34f","tags":["API","Backend"]},"recommendedPosts":[{"blog_id":"06780cd8-d961-479f-90aa-8ce6ffdcfffa","title":"MySQL Migration with Connection Pooling: A Simple Guide","short_description":"Imagine standing in line at a coffee shop where each customer needs to fill out a membership form before ordering and then tears it up after getting their coffee. Sounds inefficient, right? This is exactly what happens when your application connects to a database without connection pooling.","timestamp":"2025-04-28 13:27:45","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1745838714722_connection%20pool%20Bg.png","image_alt":"Connection Pool Labs Content","slug":"MySQL-Migration-with-Connection-Pooling-A-Simple-Guide","index":"d4735e3a265e1","tags":["Database","System Design","SQL","Backend"]},{"blog_id":"52eb37c3-83bc-4442-a8c5-305bfba74e62","title":"Why API Versioning is Really Important: A Lesson from My Own Mistake","short_description":"As a developer, I've built countless APIs for my personal projects. Some were experimental, some turned into full-fledged applications, and others were simply abandoned over time. At first, managing these APIs felt simple—if I wasn't using an endpoint anymore, I would just delete it. Why keep something that I no longer need, right?  Well, that mindset came back to bite me.","timestamp":"2025-02-16 05:35:40","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1739712690763_api-versioning-strategy.jpg","image_alt":"Api Versioning","slug":"Why-API-Versioning-is-Really-Important-A-Lesson-from-My-Own-Mistake","index":"6b86b273ff34f","tags":["API"]},{"blog_id":"f24fa0d0-6b50-494c-ab4d-49d1b302359f","title":"Building a Robust Microservices Architecture: From gRPC to Kubernetes","short_description":"In the ever-evolving world of software architecture, building a robust and scalable system is key to meeting the demands of modern applications. Recently, I had the opportunity to explore a powerful combination of technologies, starting with gRPC, translating it into HTTP/1.1, and finally deploying the system to a Kubernetes cluster. In this blog, I will take you through the journey, share the challenges I encountered, and explain why each of these steps is important for modern software systems.","timestamp":"2024-12-25 23:34:04","image":"https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2Fgrpc%20with%20kubernetes.png?alt=media&token=ae61e7f8-2088-416f-924c-512461e18206","image_alt":"Kubernetes+GRPC Background","slug":"Building-a-Robust-Microservices-Architecture-From-gRPC-to-Kubernetes","index":"6b86b273ff34f","tags":["Backend","Software Architecture","System Design","Node.Js","Docker","Cloud Computing"]}]},"__N_SSG":true}