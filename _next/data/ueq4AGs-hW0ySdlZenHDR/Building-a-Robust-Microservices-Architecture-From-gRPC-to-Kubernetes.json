{"pageProps":{"article":{"blog_id":"f24fa0d0-6b50-494c-ab4d-49d1b302359f","title":"Building a Robust Microservices Architecture: From gRPC to Kubernetes","short_description":"In the ever-evolving world of software architecture, building a robust and scalable system is key to meeting the demands of modern applications. Recently, I had the opportunity to explore a powerful combination of technologies, starting with gRPC, translating it into HTTP/1.1, and finally deploying the system to a Kubernetes cluster. In this blog, I will take you through the journey, share the challenges I encountered, and explain why each of these steps is important for modern software systems.","description":"<h2><strong>Why gRPC? Understanding Its Power in Microservices Communication</strong></h2><p>As we move toward building distributed systems, one of the key challenges is communication between services. In a typical microservices setup, services need to talk to each other to exchange data and process requests. The two most common approaches for communication are <strong>RESTful APIs</strong> and <strong>gRPC</strong>.</p><p>So, why did I choose <strong>gRPC</strong> for this project?</p><h2><strong>What Is gRPC?</strong></h2><p>gRPC (Google Remote Procedure Call) is a high-performance, language-agnostic framework for communication between services. Unlike REST, which relies on text-based protocols (typically JSON over HTTP/1.1), gRPC uses <strong>Protocol Buffers (protobuf)</strong> for serialization. This binary protocol is compact, efficient, and designed for high-performance communication, making it ideal for microservices that require fast and reliable data exchange.</p><h2><strong>Why Use gRPC for Microservices?</strong></h2><ul><li><strong>Faster Communication</strong>: gRPC’s binary protocol is more efficient than text-based protocols, reducing the overhead of parsing and serialization.</li><li><strong>Cross-Language Support</strong>: With gRPC, you can define your service in a language-neutral way and implement it in any language that supports gRPC (like Go, Java, Python, and more).</li><li><strong>Bidirectional Streaming</strong>: gRPC supports streaming, which makes it a great choice for real-time communication between services.</li></ul><p>However, as much as gRPC is great for communication between services, it’s not as widely supported by clients as HTTP/1.1, especially for web applications. This brings us to the next step in the process: <strong>translating gRPC to HTTP/1.1</strong> for broader client support.</p><h3><strong>Translating gRPC to HTTP/1.1 for Client Communication</strong></h3><p>While gRPC is fantastic for internal microservice communication, not all clients can directly communicate with gRPC servers. HTTP/1.1 is still the standard protocol for the majority of web browsers and external client requests. Therefore, I needed to expose the gRPC services through an <strong>API Gateway</strong>, which would translate incoming HTTP/1.1 requests into gRPC calls.</p><h4><strong>Why an API Gateway?</strong></h4><p>An <strong>API Gateway</strong> acts as a reverse proxy that forwards client requests to the appropriate service, handling routing, load balancing, and security concerns. In my case, it also handled translating HTTP requests into gRPC communication.</p><ul><li><strong>HTTP to gRPC Translation</strong>: The API Gateway receives HTTP requests from clients, translates them into gRPC requests, and then forwards them to the respective service. This allows you to expose gRPC services to HTTP clients without changing the core functionality of your services.</li><li><strong>Centralized Control</strong>: The API Gateway helps manage cross-cutting concerns like authentication, authorization, rate limiting, and logging, centralizing these tasks for easier management.</li></ul><h2>What we are going to build for the sample?</h2><p><img src=\"https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2Fgrpc-kubernetes-arch-project.png?alt=media&amp;token=0096deb5-89bb-4cb5-893f-e75a610e13dc\" alt=\"kubernetes+grpc architecture plan\" width=\"720px\">The project starts with the need to create a modern, scalable, and efficient architecture for handling multiple services. You aim to build a system where microservices can seamlessly communicate using gRPC for high-performance, low-latency interactions. The choice of gRPC over traditional HTTP APIs stems from its ability to use Protocol Buffers, enabling efficient serialization, lightweight message exchanges, and bi-directional streaming if needed. This makes it ideal for services like login authentication and movie information retrieval, which require quick and reliable data exchange.</p><p>In this project, you plan to create two gRPC services: one for handling user login (grpc-login-service) and another for managing movie-related data (grpc-movie-service). However, since most clients, like web browsers, communicate using HTTP 1.1 or HTTP/2, you introduce an API Gateway as the bridge. This gateway translates HTTP requests into gRPC calls, acting as the central entry point for all client communications. The gateway enables a smoother experience for clients while maintaining the performance benefits of gRPC in the backend.</p><p>To host and scale these services, you decide to deploy them on a Kubernetes cluster. Kubernetes provides a robust platform for container orchestration, ensuring that your services are resilient, scalable, and highly available. Your deployment plan includes pushing your service artifacts (Docker images) to the Google Cloud Artifact Registry and then using a 3-node Kubernetes cluster to deploy these services. Each gRPC service and the API Gateway are containerized and defined using Kubernetes YAML files for deployment and service management.</p><p>This architecture ensures a clean separation of concerns: each service focuses on its domain logic (e.g., login or movies), while the gateway abstracts communication complexities for the clients. It also leverages Kubernetes to provide automated scaling, load balancing, and fault tolerance, making the system ready for production-level traffic.</p><h2>Dive to API Gateway</h2><div><pre><code>const express = require('express');\nconst grpc = require('@grpc/grpc-js');\nconst protoLoader = require('@grpc/proto-loader');\nconst grpcWeb = require('grpc-web');\n\n// Load .proto files\nconst loginPackageDefinition = protoLoader.loadSync('login-service.proto', {\n&nbsp; &nbsp; keepCase: true,\n&nbsp; &nbsp; longs: String,\n&nbsp; &nbsp; enums: String,\n&nbsp; &nbsp; defaults: true,\n&nbsp; &nbsp; oneofs: true,\n});\n\nconst moviePackageDefinition = protoLoader.loadSync('movie-service.proto', {\n&nbsp; &nbsp; keepCase: true,\n&nbsp; &nbsp; longs: String,\n&nbsp; &nbsp; enums: String,\n&nbsp; &nbsp; defaults: true,\n&nbsp; &nbsp; oneofs: true,\n});\n\nconst loginServiceProto = grpc.loadPackageDefinition(loginPackageDefinition).LoginServiceProto;\nconst movieServiceProto = grpc.loadPackageDefinition(moviePackageDefinition).MovieServiceProto;\n\nconst app = express();\nconst port = 3000;\n\n// Set up your gRPC client\nconst login_client = new loginServiceProto('grpc-login-service:80', grpc.credentials.createInsecure());\nconst movie_client = new movieServiceProto('grpc-movie-service:80', grpc.credentials.createInsecure());\n\n// Middleware to parse JSON bodies\napp.use(express.json());\n\n// API endpoint to proxy to the gRPC service\napp.post('/api/login', (req, res) =&gt; {\n&nbsp; &nbsp; const { username, password } = req.body;\n\n&nbsp; &nbsp; // Call the gRPC method\n&nbsp; &nbsp; login_client.LoginMethod({ username, password }, (err, response) =&gt; {\n&nbsp; &nbsp; &nbsp; &nbsp; if (err) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; console.error('gRPC error:', err);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return res.status(500).send({ error: 'Internal Server Error' });\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; res.json(response);\n&nbsp; &nbsp; });\n});\n\napp.post('/api/movie', (req, res) =&gt; {\n&nbsp; &nbsp; const { title, description, rating } = req.body;\n&nbsp; &nbsp; // Call the gRPC method\n&nbsp; &nbsp; movie_client.MovieMethod({ title, description, rating }, (err, response) =&gt; {\n&nbsp; &nbsp; &nbsp; &nbsp; if (err) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; console.error('gRPC error:', err);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return res.status(500).send({ error: 'Internal Server Error' });\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; res.json(response);\n&nbsp; &nbsp; });\n});\n\n// Start the API Gateway server\napp.listen(port, () =&gt; {\n&nbsp; &nbsp; console.log(`API Gateway running at http://localhost:${port}`);\n});\n</code></pre></div><p>This code sets up a simple gRPC server for handling login requests. It begins by importing the necessary modules: @grpc/grpc-js, which provides the core gRPC functionalities, and @grpc/proto-loader, which is used to parse .proto files containing service definitions. The .proto file, login-service.proto, is loaded and configured using the protoLoader.loadSync method. This configuration ensures that field names are preserved, and specific Protocol Buffers types such as long integers, enumerations, default values, and oneof fields are appropriately handled. The loaded package definition is then passed to grpc.loadPackageDefinition to generate a usable gRPC object, which represents the LoginServiceProto service.</p><p>Next, the LoginMethod function is implemented to handle incoming login requests. This function receives the call object, which contains the client’s request data, and a callback function to send a response back to the client. It extracts the username and password from the request, constructs a success message, and sends a structured response containing the message and a status field via the callback. The response indicates that the login was processed successfully.</p><p>The gRPC server is then created using new grpc.Server(). The addService method registers the LoginServiceProto with the server and links it to the LoginMethod implementation. Finally, the server is started by binding it to the address 0.0.0.0 on port 50052 using the bindAsync method. For simplicity, the server uses insecure credentials, making it suitable for local testing but not for production. Once the server is running, a confirmation message is logged to indicate its readiness to handle incoming requests. Overall, this code provides a robust foundation for handling login operations as part of a microservices-based architecture. It enables fast and efficient communication between services through the gRPC protocol.</p><h2><strong>Dive to GRPC Service</strong></h2><div><pre><code>const grpc = require('@grpc/grpc-js');\nconst protoLoader = require('@grpc/proto-loader');\n\n\n// Load the .proto file\nconst packageDefinition = protoLoader.loadSync('movie-service.proto', {\n&nbsp; &nbsp; keepCase: true,\n&nbsp; &nbsp; longs: String,\n&nbsp; &nbsp; enums: String,\n&nbsp; &nbsp; defaults: true,\n&nbsp; &nbsp; oneofs: true,\n});\nconst MovieServiceProto = grpc.loadPackageDefinition(packageDefinition).MovieServiceProto;\n\n\n// Implement the ExampleMethod RPC\nfunction MovieMethod(call, callback) {\n&nbsp; &nbsp; const { title, description, rating } = call.request;\n&nbsp; &nbsp; const message = `Thank you for the feedback. The Movie Title is ${title} and the description is ${description} has a rating of ${rating}.`;\n&nbsp; &nbsp; const response = {\n&nbsp; &nbsp; &nbsp; &nbsp; message: message,\n&nbsp; &nbsp; &nbsp; &nbsp; status: 'success',\n&nbsp; &nbsp; }\n&nbsp; &nbsp; callback(null, response);\n}\n\n\n// Create the gRPC server\nconst server = new grpc.Server();\nserver.addService(MovieServiceProto.service, { MovieMethod: MovieMethod });\n\n\n// Start the server\nconst port = '0.0.0.0:50051';\nserver.bindAsync(port, grpc.ServerCredentials.createInsecure(), () =&gt; {\n&nbsp; &nbsp; console.log(`gRPC server running at ${port}`);\n});\n</code></pre></div><p>This code defines a gRPC server for handling requests related to movies. The server is built using the @grpc/grpc-js library for gRPC functionality and the @grpc/proto-loader library to load the .proto file that defines the movie service. Here's how it works in detail:</p><p>First, the .proto file (movie-service.proto) is loaded using protoLoader.loadSync. The protoLoader processes the Protocol Buffers definition into a format compatible with gRPC in Node.js. The options provided during the load process, such as keepCase, longs, and defaults, ensure that the original structure of the Protocol Buffers definition is preserved and mapped appropriately in JavaScript. The loaded package definition is then used to retrieve the MovieServiceProto object, which represents the service described in the .proto file.</p><p>Next, the MovieMethod function is implemented as the core logic for handling the gRPC request. This method represents an RPC (Remote Procedure Call) defined in the .proto file. When a client sends a request to this method, it provides details about a movie, such as title, description, and rating. The server responds by constructing a message that acknowledges the feedback and includes the provided details. A response object is created, which contains a message and a success status, and this is sent back to the client using the callback function.</p><p>The gRPC server is then created using new grpc.Server(). The addService method registers the MovieServiceProto.service with the server and maps it to the implementation (MovieMethod). This ensures that whenever a request for the MovieMethod RPC is received, the defined function is executed.</p><p>Finally, the server is started on port 50051 using the bindAsync method. The grpc.ServerCredentials.createInsecure() method specifies that the server will run without encryption, suitable for development environments. Once the server is bound to the specified port, it logs a confirmation message to the console, indicating that the gRPC server is running and ready to handle requests.</p><p>This setup is crucial for your project, as it provides the backend logic for handling movie-related data. It showcases how gRPC enables structured communication between services while maintaining high performance and clear data contracts defined in the .proto file.</p><p><strong>Note</strong>: There is another grpc service that implemented. and its excluding in this topic. You can create more similiar grpc service like above code.</p><h2><strong>Creating Dockerfile</strong></h2><p>To containerize your gRPC service and push it to Google Artifact Registry, you'll use a Dockerfile to define the container's build process and interact with the Artifact Registry to store your container image. Here's how you can approach this process:</p><p>The Dockerfile provides instructions for building the container image for your gRPC service. Below is an example Dockerfile for the movie-service:</p><div><pre><code># Use the official Node.js image as a base\nFROM node:16-alpine\n\n\n# Set the working directory in the container\nWORKDIR /usr/src/app\n\n\n# Copy the package.json and package-lock.json\nCOPY package*.json ./\n\n\n# Install dependencies\nRUN npm install\n\n\n# Copy the application code to the container\nCOPY . .\n\n\n# Expose the port the gRPC server will run on\nEXPOSE 50051\n\n\n# Start the gRPC service\nCMD [\"node\", \"index.js\"]\n</code></pre></div><p><strong>Explanation</strong>:</p><p>1. Base Image: We use the lightweight node:16-alpine image to reduce the container size while still providing all necessary Node.js dependencies.</p><p>2. Working Directory: The WORKDIR sets the container's working directory to /usr/src/app.</p><p>3. Copying Files: The COPY instructions add your package.json and the rest of your application files to the container.</p><p>4. Installing Dependencies: The RUN npm install command ensures that all required dependencies are installed.</p><p>5. Exposing Port: The EXPOSE 50051 makes the gRPC service accessible on port 50051.</p><p>6. Starting the Service: The CMD defines the command to run your gRPC service when the container starts.</p><p>7. Building the Docker Image</p><p>After creating the Dockerfile, you can build the Docker image for your gRPC service using the following command:</p><div><pre><code>docker build -t movie-service .\n</code></pre></div><p>This command tags the image as movie-service and uses the current directory (.) as the build context.</p><p><strong>Note</strong>: This Dockerfile only represent single project which refers to one of grpc service. You can create another Dockerfile for another service. which not really different with this one.</p><h2><strong>Tagging and Pushing to Artifact Registry</strong></h2><p>This approach allowed Kubernetes (GKE) to seamlessly retrieve and deploy the correct images for each service, ensuring a smooth and reliable deployment process.</p><p>To push the image to Google Artifact Registry, follow these steps:</p><p><strong>- Authenticate with Google Cloud</strong>: Run the following command to configure Docker to use Google Cloud credentials:</p><div><pre><code>gcloud auth configure-docker\n</code></pre></div><p><strong>- Tag the Image for Artifact Registry</strong>: Replace &lt;region&gt;, &lt;project-id&gt;, and &lt;repository-name&gt; with your Artifact Registry details. For example:</p><div><pre><code>docker tag movie-service &lt;region&gt;-docker.pkg.dev/&lt;project-id&gt;/&lt;repository-name&gt;/movie-service\n</code></pre></div><p><strong>- Push the Image</strong>: Push the tagged image to the Artifact Registry:</p><div><pre><code>docker push &lt;region&gt;-docker.pkg.dev/&lt;project-id&gt;/&lt;repository-name&gt;/movie-service\n</code></pre></div><h2><strong>Kubernetes Setup</strong></h2><p>To deploy your gRPC services to Kubernetes on Google Kubernetes Engine (GKE), you'll go through several steps, including creating the GKE cluster, setting up YAML files for deployments and services, and deploying the services. Here's a step-by-step explanation:</p><h3><strong>1. Creating a Kubernetes Cluster in GKE</strong></h3><p>First, you'll create a GKE cluster to host your services.</p><h4><strong>Step 1: Enable Required APIs</strong></h4><p>Ensure you have the GKE and Artifact Registry APIs enabled for your project:</p><div><pre><code>gcloud services enable container.googleapis.com artifactregistry.googleapis.com\n</code></pre></div><h4><strong>Step 2: Create the GKE Cluster</strong></h4><p>Run the following command to create a Kubernetes cluster:</p><div><pre><code>gcloud container clusters create grpc-cluster \\\n    --num-nodes=3 \\\n    --region=us-central1 \\\n    --enable-ip-alias\n</code></pre></div><p>--num-nodes=3: Creates a cluster with 3 nodes.</p><p>--region=us-central1: Specifies the cluster region. Adjust this based on your location.</p><p>--enable-ip-alias: Enables VPC-native networking.</p><h4><strong>Step 3: Connect to the Cluster</strong></h4><p>To interact with your GKE cluster, fetch its credentials:</p><div><pre><code>gcloud container clusters get-credentials grpc-cluster --region=us-central1\n</code></pre></div><p>Now, your local kubectl command is connected to your GKE cluster.</p><h3><strong>2. Preparing Kubernetes YAML Files</strong></h3><p>You need two types of YAML files for each service: a Deployment file and a Service file.</p><p>Example: Deployment YAML (movie-service-deployment.yaml)</p><p>This file defines how your gRPC service is deployed.</p><div><pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: movie-service\n  labels:\n    app: movie-service\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: movie-service\n  template:\n    metadata:\n      labels:\n        app: movie-service\n    spec:\n      containers:\n      - name: movie-service\n        image: us-central1-docker.pkg.dev/&lt;project-id&gt;/&lt;repository-name&gt;/movie-service:latest\n        ports:\n        - containerPort: 50051\n</code></pre></div><p>Explanation:</p><p>- replicas: Specifies the number of pod instances for the service.</p><p>- image: Points to the Docker image in Google Artifact Registry.</p><p>- ports: Exposes port 50051, which the gRPC service listens to.</p><p>Example: Service YAML (movie-service-service.yaml)</p><p>This file exposes your gRPC service within the cluster or to the internet.</p><div><pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: movie-service\nspec:\n  selector:\n    app: movie-service\n  ports:\n  - protocol: TCP\n    port: 50051\n    targetPort: 50051\n  type: ClusterIP\n</code></pre></div><h4>Explanation:</h4><p><strong>type</strong>: ClusterIP: Exposes the service within the Kubernetes cluster. Use LoadBalancer if you need external access.</p><p><strong>targetPort</strong>: Maps the service port to the container port.</p><h3><strong>3. Deploying the Services</strong></h3><p>After creating the YAML files, apply them to your cluster.</p><h4><strong>Step 1: Deploy the Movie Service</strong></h4><p>Run the following commands:</p><div><pre><code>kubectl apply -f movie-service-deployment.yaml\nkubectl apply -f movie-service-service.yaml\n</code></pre></div><h4><strong>Step 2: Verify the Deployment</strong></h4><p>Check the pods and services to ensure they are running:</p><div><pre><code>kubectl get pods\nkubectl get svc\n</code></pre></div><h3><strong>4. Deploying Additional Services</strong></h3><p>Follow the same process for your login service:</p><p>1. Create login-service-deployment.yaml and login-service-service.yaml.</p><p>2. Apply the YAML files using kubectl apply.</p><h2><strong>Conlusion</strong></h2><p>Building a modern, scalable system is more than just deploying code—it's a journey into the intricacies of microservices, networking, containerization, and orchestration. From the outset, we delved into the necessity of gRPC, unlocking fast, efficient communication between services. By creating two gRPC services. we saw how to design robust servers capable of processing structured requests and returning meaningful responses. Translating these gRPC methods into HTTP/1.1 via an API Gateway expanded their accessibility, making them usable by any client.</p><p>Docker came into play as the backbone of portability and consistency, enabling us to containerize and push our services to Google Artifact Registry. With Kubernetes, we embraced the power of orchestration, deploying services on a GKE cluster, ensuring high availability, load balancing, and seamless scaling. YAML files gave us control over deployments, allowing precise management of replicas, ports, and service types. The API Gateway tied everything together, creating a single point of entry for clients while efficiently routing traffic to the respective gRPC services.</p><p>This project showcases not just technical implementations but also the thought process behind building scalable, maintainable systems. Each step—from writing the first line of code to testing the final deployment—demonstrates the power of modern tools and practices. It's a reminder of how containerization, orchestration, and thoughtful design transform complex challenges into elegant solutions.</p><p>The journey doesn’t stop here. With this foundation, the possibilities are limitless—whether adding more services, optimizing deployments, or exploring advanced Kubernetes features like autoscaling and monitoring. This project serves as a testament to the potential of modern cloud-native development and a stepping stone for future innovation.</p><p>So here’s to embracing complexity, simplifying solutions, and building systems that not only work but inspire. The world of scalable systems awaits—where will you take it next?</p>","timestamp":"Thursday, December 26, 2024 at 7:34:04 AM GMT+8","image":"https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2Fgrpc%20with%20kubernetes.png?alt=media&token=ae61e7f8-2088-416f-924c-512461e18206","image_alt":"Kubernetes+GRPC Background","slug":"Building-a-Robust-Microservices-Architecture-From-gRPC-to-Kubernetes","index":"6b86b273ff34f","tags":["Backend","Software Architecture","System Design","Node.Js","Docker","Cloud Computing"]},"recommendedPosts":[{"blog_id":"36855ea7-b37b-4b4c-91f1-27d90b9bde59","title":"Understanding Database Partitioning vs Sharding: Concepts, Benefits, and Challenges","short_description":"When dealing with large volumes of data, efficient database management becomes essential. Two widely used techniques to improve performance and scalability are database partitioning and database sharding. Although often confused, these approaches differ fundamentally in architecture, complexity, and suitable use cases. This article explores these differences in detail, helping you decide which fits your application best.","timestamp":"2025-05-17 09:42:15","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1747474398774_partition%20vs%20sharding%20db.png","image_alt":"partition vs sharding Database","slug":"Understanding-Database-Partitioning-vs-Sharding-Concepts-Benefits-and-Challenges","index":"d4735e3a265e1","tags":["Database","Database Architecture","Software Architecture","System Design"]},{"blog_id":"675f800c-08cb-459f-aa7d-44cdc9c9c169","title":"System Design Simplified: The Trade-Off Triangle You Must Master","short_description":"Behind every well-architected system is a set of tough decisions. The CAP Theorem simplifies those decisions by showing you what you must give up to keep your system fast, correct, and resilient. Learn how to apply this in real-world architecture.","timestamp":"2025-05-13 01:58:48","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1747100859417_CAP%20BG.jpg","image_alt":"CAP background","slug":"System-Design-Simplified-The-Trade-Off-Triangle-You-Must-Master","index":"d4735e3a265e1","tags":["System Design","CAP Theorem","Distributed Systems"]},{"blog_id":"5c2626c4-8a10-47f1-8c5c-b3ac2d84b69a","title":"Why Domain-Driven Design (DDD) Matters: From Chaos to Clarity in Complex Systems","short_description":"Domain-Driven Design (DDD) is a powerful approach to software development that places the business domain—not the technology—at the center of your design decisions. First introduced by Eric Evans, DDD is essential for developers and architects who want to build systems that reflect real-world complexity and change.","timestamp":"2025-05-12 04:23:04","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1747022797381_Domain-Driven-Design_cover.jpg","image_alt":"DDD Cover","slug":"Why-Domain-Driven-Design-DDD-Matters-From-Chaos-to-Clarity-in-Complex-Systems","index":"d4735e3a265e1","tags":["DDD","Software Architecture","System Design"]}]},"__N_SSG":true}