{"pageProps":{"article":{"blog_id":"14d690d3-2201-43e4-b936-e06564ab67e2","title":"React PWA Fundamental","short_description":"A Progressive Web App is a type of web application that combines the best features of web and mobile applications. PWAs can be accessed through a web browser but can also be installed on a user's device like traditional mobile apps.","description":"<h1>React PWA Fundamental</h1><p>A Progressive Web App is a type of web application that combines the best features of web and mobile applications. PWAs can be accessed through a web browser but can also be installed on a user's device like traditional mobile apps. Some key features of PWAs include:</p><ul><li>The ability to work offline</li><li>Fast performance</li><li>Responsive display on various devices</li><li>Access through an icon on the device's home screen</li></ul><p>in this case we will be focused on how to make our react applicaion running on offline, get the requested react module from cache instead from the server. we will be learn about how to cache the customs api fetch that can be store to our react application.</p><h2>What Are Service Workers?</h2><p>Service Workers are a crucial part of PWAs. They are JavaScript files that run in the background and enable features like offline caching, push notifications, and background sync. Service Workers act as intermediaries between your web application and the network, allowing you to control how your PWA behaves in various scenarios.</p><h2>VITE React PWA</h2><p>In Vite React Project, there is some special configuration needed to applied the Progressive Web App. Below is the step-by-step to configure the PWA.</p><h3>Installing vite-plugin-pwa</h3><p>First we need to install the vite-plugin-pwa plugin, just add it to your project as a dev dependency:</p><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\">npm install -D vite-plugin-pwa</code></pre><p>Note: to running the implementation of PWA, we need to to build our react vite project, then running the react vite project trough npm run preview. There is some extra configuration to make implementation of PWA running in development mode.</p><h3>Configuring vite-plugin-pwa</h3><p>Edit your vite.config.js / vite.config.ts file and add the vite-plugin-pwa:</p><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\">import { defineConfig } from 'vite'\nimport { VitePWA } from 'vite-plugin-pwa'\nimport react from '@vitejs/plugin-react'\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [\n    react(),\n    VitePWA({\n      registerType: 'autoUpdate',\n      workbox: {\n        globPatterns: ['**/*.{js,css,html,ico,png,svg}']\n      }\n    })\n  ],\n})</code></pre><h3>Cache External Resources</h3><p>If you have some additional resource like font and css, you must include them into the service workerpre-cache and so your application will work when offline. But in this scenario, we will trying to use some free-api named: https://jsonplaceholder.typicode.com. to fetch the data from it and then stored it to the cache browser. so it can be rendered to a front-end page without the network traffic. The implementation is very easy. we need to addd some property in workbox object named :runtimeCaching. Below the example of how to use it:</p><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\"> runtimeCaching: [\n          {\n            urlPattern: ({ url }) =&gt; {\n              return url.pathname.match('/posts/1')\n            },\n            handler: 'CacheFirst',\n            options: {\n              cacheName: 'api-cache',\n              cacheableResponse: {\n                statuses: [0, 200]\n              }\n            }\n          }\n        ]</code></pre><h2>Result Excercise</h2><p>Below is the result example of how the PWA can running the application without the network traffic and requested from the server.</p><img src='https://raw.githubusercontent.com/Barbarpotato/React-PWA-Fundamental/main/git-images/Result.png?token=GHSAT0AAAAAABT2NYLCZWUIB25VOK65BHRIZI6WNAA'/><h2>Service Worker without PWA capabilities</h2><p>Sometimes you don't need the full blown PWA functionality like offline cache and manifest file, but need simple custom Service Worker.</p><h3>Setup the Service Worker</h3><p>You can first check the browsers are supporting the service worker by create the script like below:</p><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\">  &lt;script&gt;\n    if ('serviceWorker' in navigator) {\n      window.addEventListener('load', () =&gt; {\n        navigator.serviceWorker.register('/src/serviceWorker.js').then((reg) =&gt; {\n          console.log('Worker Registered!')\n        }).catch(err =&gt; {\n          console.log('Error in service Worker', err)\n        })\n      })\n    }\n  &lt;/script&gt;</code></pre><p>This this code is responsible for registering a service worker for your web application.</p><h2>Offline Caching</h2><p>If the services worker is available (it whill show the Worker Registered in your broswer console). Now let's create the serviceWorker.js file in public directory. We can squeeze the serviceWorker file by create some eventlistener that installed some assests from server to Cache Storage. So the client is not calling the resource from the server anymore instead calling from the client browser cache data.</p><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\">self.addEventListener('install', (event) =&gt; {\n    event.waitUntil(\n        caches.open('PWA-Cache').then((caches) =&gt; {\n            console.log('Opened Cache')\n            return caches.addAll([\n                './assets/react.svg',\n                '/vite.svg'\n            ])\n        })\n    )\n})</code></pre><p>The purpose of this install event handler is to cache these specified assets when the service worker is first installed. Once the assets are cached, they can be served from the cache even if the user is offline, providing offline access to these resources. This is a fundamental step in building Progressive Web Apps (PWAs) that work seamlessly offline.</p><p><br></p><p>After installing all assest from the server to the client. we need to tell the browser that whenever we fetch the data, we need to check the browser cache data first before we calling the server resource. if the client request it is same as the data from a data cache browser, then just use the cache browser data. Below is the example of how the explanation above implemented in javascript:</p><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\">self.addEventListener('fetch', (event) =&gt; {\n    event.respondWith(\n        caches.match(event.request).then((response) =&gt; {\n            if (response) {\n                // Cache hit, return the response\n                return response;\n            }\n            // Not found in cache, fetch from the network\n            return fetch(event.request);\n        })\n    );\n});</code></pre>","timestamp":"Friday, September 20, 2024 at 11:37:12 AM GMT+8","image":"https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2Freact-pwa.png?alt=media&token=2b264f65-ddf9-4b4a-afa8-efb39cb13c3d","image_alt":"Progressive Web App","slug":"react-pwa-fundamental","index":"6b86b273ff34f","tags":["React.js","Frontend"]},"recommendedPosts":[{"blog_id":"f0946042-0217-47f4-9064-bb5740b6c72c","title":"How to Set Up Push Notifications in Expo with Firebase for Android (Production-Ready Guide)","short_description":"In this guide, you'll learn how to set up Expo push notifications for Android, including the correct use of Firebase Admin SDK credentials, how to upload them securely, and how to properly configure your Expo app.","timestamp":"2025-05-17 10:16:38","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1747476529014_push_notif%20bg.jpg","image_alt":"push notif token expo bg","slug":"How-to-Set-Up-Push-Notifications-in-Expo-with-Firebase-for-Android-Production-Ready-Guide","index":"d4735e3a265e1","tags":["Frontend","Android","Mobile App","React Native"]},{"blog_id":"aa6d33ed-f439-4fa4-9109-38427155b685","title":"Creating a Reusable React Layout Package via GitHub (Without npm Publish)","short_description":"If you often reuse the same Navbar, Footer, or other layout components across multiple React projects, maintaining them in each repo becomes redundant and error-prone. A better approach is to extract them into a shared GitHub package.","timestamp":"2025-05-04 02:42:53","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1746326014972_Github%20Packages.webp","image_alt":"Github Packaging","slug":"Creating-a-Reusable-React-Layout-Package-via-GitHub-Without-npm-Publish","index":"d4735e3a265e1","tags":["Github","Package","Library","Software Development","Frontend"]},{"blog_id":"e7d3943c-c12a-42c1-9663-2d90449138dc","title":"The concept of splitting a frontend into smaller, manageable pieces.","short_description":"Have you ever worked on a massive frontend application where every change felt risky and deploying updates took ages? If so, micro frontends might be the solution youâ€™ve been looking for","timestamp":"2024-12-04 03:23:45","image":"https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2Fmicrofrontend.webp?alt=media&token=6274c176-9622-4cd5-93be-9ea9e5912bd9","image_alt":"Microfrontend Image Cover","slug":"the-concept-of-splitting-a-frontend-into-smaller-manageable-pieces","index":"6b86b273ff34f","tags":["Frontend","Software Architecture","System Design"]}]},"__N_SSG":true}