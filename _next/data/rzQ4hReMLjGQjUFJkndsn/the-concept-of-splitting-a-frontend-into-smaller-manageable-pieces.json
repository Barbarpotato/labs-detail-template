{"pageProps":{"article":{"blog_id":"e7d3943c-c12a-42c1-9663-2d90449138dc","title":"The concept of splitting a frontend into smaller, manageable pieces.","short_description":"Have you ever worked on a massive frontend application where every change felt risky and deploying updates took ages? If so, micro frontends might be the solution you’ve been looking for","description":"<p>Micro frontends are an architectural approach that applies the principles of microservices to frontend development. Instead of building a single, monolithic frontend application, the user interface is divided into smaller, independent pieces called <strong>micro frontends</strong>, each of which is developed, deployed, and maintained independently.</p><h1><strong>The Problem with Monolithic Frontends</strong></h1><p>A <strong>monolithic frontend</strong> refers to a single, large codebase that manages the entire user interface of an application. While this approach works well for small applications, it becomes increasingly challenging to manage and scale as the application and development teams grow. Below are the key problems associated with monolithic frontends:</p><h2><strong>1. Scaling Teams</strong></h2><ul><li><strong>Coordination Overhead</strong>: In a large team, multiple developers work on the same codebase. This can lead to frequent merge conflicts, delayed pull requests, and dependency issues.</li><li><strong>Limited Parallel Development</strong>: Because the codebase is tightly coupled, teams cannot work independently on different parts of the application without stepping on each other's toes.</li></ul><h2><strong>2. Slower Development Cycles</strong></h2><ul><li><strong>Single Deployment Pipeline</strong>: In a monolithic frontend, all changes must pass through the same build and deployment pipeline. This means Small changes (e.g., fixing a typo) require deploying the entire application, also A single bug can block the entire release process.</li><li><strong>Longer Testing Time</strong>: The larger the application, the more time and effort it takes to ensure that new changes don’t break existing functionality.</li></ul><h2><strong>3. High Risk of Changes</strong></h2><ul><li><strong>Ripple Effect</strong>: Since everything is interconnected, even small changes in one part of the application can have unintended consequences elsewhere.</li><li><strong>Rollback Challenges</strong>: If something goes wrong after deployment, rolling back requires reverting the entire application, not just the problematic component.</li></ul><h2><strong>4. Tech Stack Lock-In</strong></h2><ul><li><strong>Difficult to Adopt New Frameworks</strong>: In a monolithic frontend, the entire application is built using a single framework or library. Upgrading or switching technologies is a monumental task that may require rewriting the entire application. <strong>Example</strong>: Migrating from AngularJS to React would involve significant effort and downtime.</li><li><strong>No Flexibility for Teams</strong>: Teams must stick to the same tech stack, even if certain parts of the application would benefit from newer or more suitable tools.</li></ul><h1><strong>How Micro Frontends Work</strong></h1><p>Micro frontends operate on the principle of <strong>divide and conquer</strong>. Instead of managing one gigantic codebase, you divide your application into smaller units.</p><p>The idea behind micro frontends is simple yet powerful:</p><p><strong>1. Divide</strong> your application into smaller, self-contained pieces.</p><p><strong>2. Conquer</strong> by developing, testing, and deploying these pieces independently.</p><p>Instead of one massive codebase where every change has the potential to disrupt the entire application, you get a collection of smaller, focused units that can evolve at their own pace. Here is the breakdown of how divide and conquer works in microfrontend.</p><p><br></p><p><img src=\"https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2Fmonolit_vs_microfrontend.png?alt=media&amp;token=24eba3d8-b7f3-4674-b33e-62daf0517afd\" alt=\"Monolithic Vs Microfrontend\" width=\"720px\"></p><p><br></p><p>In a traditional monolithic architecture (left side), all components of a web application are tightly coupled and deployed as a single unit. This includes the web application layer (frontend), integration layer (APIs), and service layer (backend).</p><p>Microfrontends (right side) break down a large web application into smaller, independent frontend applications (also called \"micro-applications\" or \"micro-frontends\"). Each microfrontend is responsible for a specific feature or section of the application. This approach promotes modularity, scalability, and faster development cycles.</p><p>The divide and conquer approach is central to microfrontends. It involves:</p><h3><strong>Dividing the Application:</strong></h3><ol><li><strong>Identify Features:</strong> First, break down the application into distinct features or sections. For example, in the image, we have \"Cart,\" \"Website,\" and \"Payment\" as separate features.</li><li><strong>Assign Teams:</strong> Each feature is assigned to an independent team. This allows teams to work autonomously, focusing on their specific feature.</li></ol><h3><strong>Conquering the Features:</strong></h3><ol><li><strong>Independent Development:</strong> Each team develops its feature as a standalone frontend application. They can use different technologies (React, JAML, etc.) and frameworks as needed.</li><li><strong>API Integration:</strong> Teams define clear APIs for their microfrontends to communicate with each other and with the backend services. This ensures loose coupling and flexibility.</li></ol><h3><strong>Composition and Orchestration:</strong></h3><ol><li><strong>Frameworks and Tools:</strong> A framework or library is used to combine the microfrontends into a cohesive user experience. This can be done using techniques like server-side composition (e.g., with a Node.js server) or client-side composition (e.g., with a JavaScript framework like Single-SPA).</li><li><strong>Routing and Navigation:</strong> The framework handles routing and navigation between microfrontends, ensuring a seamless user experience.</li><li><strong>Shared Components:</strong> If necessary, shared components can be developed and used across multiple microfrontends. This promotes consistency and reduces code duplication.</li></ol><h1>Conclusion</h1><p>Micro frontends represent a modern approach to building scalable, resilient, and maintainable frontend applications. By breaking down your application into smaller, independent pieces, you empower your teams to innovate faster and reduce deployment risks.. If you’ve ever felt constrained by the limitations of a monolithic frontend, it might be time to explore the possibilities of micro frontends. They’re not just a technical solution—they’re a way to rethink how we build for the web.</p>","timestamp":"Wednesday, December 4, 2024 at 11:23:45 AM GMT+8","image":"https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2Fmicrofrontend.webp?alt=media&token=6274c176-9622-4cd5-93be-9ea9e5912bd9","image_alt":"Microfrontend Image Cover","slug":"the-concept-of-splitting-a-frontend-into-smaller-manageable-pieces","index":"6b86b273ff34f","tags":["Software Architecture","System Design","Frontend"]},"recommendedPosts":[{"blog_id":"f0946042-0217-47f4-9064-bb5740b6c72c","title":"How to Set Up Push Notifications in Expo with Firebase for Android (Production-Ready Guide)","short_description":"In this guide, you'll learn how to set up Expo push notifications for Android, including the correct use of Firebase Admin SDK credentials, how to upload them securely, and how to properly configure your Expo app.","timestamp":"2025-05-17 10:16:38","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1747476529014_push_notif%20bg.jpg","image_alt":"push notif token expo bg","slug":"How-to-Set-Up-Push-Notifications-in-Expo-with-Firebase-for-Android-Production-Ready-Guide","index":"d4735e3a265e1","tags":["Frontend","Android","Mobile App","React Native"]},{"blog_id":"36855ea7-b37b-4b4c-91f1-27d90b9bde59","title":"Understanding Database Partitioning vs Sharding: Concepts, Benefits, and Challenges","short_description":"When dealing with large volumes of data, efficient database management becomes essential. Two widely used techniques to improve performance and scalability are database partitioning and database sharding. Although often confused, these approaches differ fundamentally in architecture, complexity, and suitable use cases. This article explores these differences in detail, helping you decide which fits your application best.","timestamp":"2025-05-17 09:42:15","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1747474398774_partition%20vs%20sharding%20db.png","image_alt":"partition vs sharding Database","slug":"Understanding-Database-Partitioning-vs-Sharding-Concepts-Benefits-and-Challenges","index":"d4735e3a265e1","tags":["Database","Database Architecture","Software Architecture","System Design"]},{"blog_id":"675f800c-08cb-459f-aa7d-44cdc9c9c169","title":"System Design Simplified: The Trade-Off Triangle You Must Master","short_description":"Behind every well-architected system is a set of tough decisions. The CAP Theorem simplifies those decisions by showing you what you must give up to keep your system fast, correct, and resilient. Learn how to apply this in real-world architecture.","timestamp":"2025-05-13 01:58:48","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1747100859417_CAP%20BG.jpg","image_alt":"CAP background","slug":"System-Design-Simplified-The-Trade-Off-Triangle-You-Must-Master","index":"d4735e3a265e1","tags":["System Design","CAP Theorem","Distributed Systems"]}]},"__N_SSG":true}