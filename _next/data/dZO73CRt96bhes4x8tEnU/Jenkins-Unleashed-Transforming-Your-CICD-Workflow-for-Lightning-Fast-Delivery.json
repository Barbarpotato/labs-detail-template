{"pageProps":{"article":{"blog_id":"109a123a-02ae-4b9f-96a9-785428eef2fa","title":"Jenkins Unleashed: Transforming Your CI/CD Workflow for Lightning-Fast Delivery","short_description":"In the fast-paced world of modern software development, delivering high-quality applications quickly is no longer optional—it's essential. This is where Jenkins steps in as a game-changer. Imagine having a virtual assistant that tirelessly builds, tests, and deploys your code, ensuring every update you make reaches production seamlessly.","description":"<h1><strong>Why Use Jenkins for CI/CD?</strong></h1><p>Jenkins is not just a tool; it's a culture shifter. With its unparalleled flexibility, thousands of plugins, and vibrant community, Jenkins transforms how teams approach Continuous Integration and Continuous Delivery (CI/CD). Whether you’re a small startup racing to push your MVP or a large enterprise managing complex workflows, Jenkins empowers you to automate repetitive tasks, reduce errors, and accelerate delivery pipelines.</p><p>But why Jenkins? It’s open-source, highly customizable, and scales effortlessly with your team’s growing needs. It’s the bridge between developers and operations teams, breaking down silos and fostering collaboration in ways you’ve never experienced before.</p><p>In this labs, we’ll explore the magic of Jenkins and why it’s the go-to choice for CI/CD pipelines. Ready to revolutionize your development workflow? Let’s dive in!</p><h1><strong>Setting Up CI/CD in Jenkins</strong></h1><p>To start setting up CI/CD with Jenkins, the first step is to prepare your environment by installing Java. Jenkins requires Java to run, so you need to install OpenJDK 17. Update your system packages and install Java by running the following commands:</p><div><pre><code>sudo apt update\nsudo apt install fontconfig openjdk-17-jre\njava -version\n</code></pre></div><p>After installation, you can verify the version of Java to ensure everything is properly set up. The output should display the installed version, such as openJDK version 17. With Java in place, your system is now ready to host Jenkins.</p><p>Next, install Jenkins using its official package repository to ensure you're getting the latest stable release. First, add Jenkins' repository key and configuration to your system, update the package list, and install Jenkins by running these commands:</p><div><pre><code>sudo wget -O /usr/share/keyrings/jenkins-keyring.asc \\\n  https://pkg.jenkins.io/debian-stable/jenkins.io-2023.key\necho \"deb [signed-by=/usr/share/keyrings/jenkins-keyring.asc]\" \\\n  https://pkg.jenkins.io/debian-stable binary/ | sudo tee \\\n  /etc/apt/sources.list.d/jenkins.list &gt; /dev/null\nsudo apt-get update\nsudo apt-get install jenkins\n</code></pre></div><p>Once Jenkins is installed, you need to enable and start the Jenkins service. This ensures Jenkins runs immediately and starts automatically whenever the system boots. Use the following commands to enable and start Jenkins:</p><div><pre><code>sudo systemctl enable jenkins\nsudo systemctl start jenkins\nsudo systemctl status jenkins\n</code></pre></div><p>After starting the service, you can access Jenkins through your browser. Open http://[VM_EXTERNAL_IP]:8080&nbsp;and log in using the initial admin password. To retrieve this password, run:</p><div><pre><code>sudo cat /var/lib/jenkins/secrets/initialAdminPassword\n</code></pre></div><p>Enter the password on the setup screen and follow the guided setup wizard. This process will include installing recommended plugins, such as Git, Pipeline, Blue Ocean, and GitHub, which are essential for building your CI/CD pipeline.</p><p>In addition to plugins, configure credentials for accessing your source code repository. Navigate to <strong>Manage Jenkins &gt; Credentials</strong>, and add secure credentials for platforms like GitHub or GitLab. This setup ensures your pipeline can pull code from your repositories securely.</p><p>With Jenkins configured, you’re ready to create your first pipeline. The pipeline script can define all stages of your CI/CD process, such as fetching code, running tests, and deploying to production.</p><h1><strong>Setting Up Git Credentials for Private Repositories</strong></h1><p>If your project is hosted on a private Git platform, you’ll need to provide secure credentials for Jenkins to access the repository. For GitHub users, this involves creating a Personal Access Token (PAT) and adding it to Jenkins' credentials. This ensures seamless integration between Jenkins and your repository without compromising security.</p><h2><strong>Creating a Personal Access Token (PAT) on GitHub</strong></h2><p>To create a PAT in GitHub:</p><p>1. Go to your GitHub account settings.</p><p>2. Navigate to Developer settings &gt; Personal Access Tokens &gt; Tokens (classic).</p><p>3. Click Generate new token and specify the required permissions. For most CI/CD setups, select scopes like repo (for repository access) and workflow (if managing GitHub Actions).</p><p>4. Generate the token and copy it. Make sure to store it securely as you won’t be able to view it again.</p><h2>Configuring Jenkins with GitHub Credentials</h2><p>Once you’ve created your PAT, follow these steps to add it to Jenkins:</p><p>1. Log in to the Jenkins Dashboard.</p><p>2. Navigate to Manage Jenkins &gt; Manage Credentials.</p><p>3. Under (global) credentials, click Add Credentials.</p><p>4. In the Kind dropdown, select Username with password.</p><p>Username: Enter your GitHub username (e.g., username).</p><p>Password: Paste the PAT you just created.</p><p>5. Give the credential a recognizable ID (e.g., github-creds) and click OK.</p><h1>Writing Your First Jenkins Pipeline</h1><p>With Jenkins configured, you’re ready to create your first pipeline. The pipeline script defines all stages of your CI/CD process, including fetching code, running tests, and deploying the application. Let’s walk through an example pipeline written using Jenkins' declarative syntax, which simplifies the process and ensures better readability.</p><h4>Understanding the Pipeline Script</h4><p>Below is an example pipeline that automates three key stages of the CI/CD process:</p><p><strong>1. Fetching the code from GitHub</strong> using credentials for a secure connection.</p><p><strong>2. Running basic testing commands</strong> to verify the environment setup.</p><p><strong>3. Deploying the application</strong> to a server using SSH for remote commands</p><div><pre><code>pipeline {\n&nbsp; &nbsp; agent any\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; environment {\n&nbsp; &nbsp; &nbsp; &nbsp; GITHUB_CREDENTIALS = 'caea020d-a24e-4305-bdc2-d7e51d1c8171'&nbsp; // ID of the GitHub credentials in Jenkins\n&nbsp; &nbsp; }\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; stages {\n&nbsp; &nbsp; &nbsp; &nbsp; stage('Git Checkout') {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; steps {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; script {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Cloning the GitHub repository using the provided credentials\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; git credentialsId: \"${GITHUB_CREDENTIALS}\", url: 'https://github.com/Barbarpotato/API-Registry.git', branch: 'main'\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; stage('Run Testing Commands') {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; steps {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sh 'hostname'&nbsp; // Outputs the hostname of the Jenkins agent\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sh 'pwd'&nbsp; &nbsp; &nbsp; &nbsp;// Displays the current working directory in the agent's workspace\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; stage('Deploy to Server') {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; steps {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Using SSH to deploy the application to the target server\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sshagent(['ssh-key-gateway']) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sh '''\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ssh -o StrictHostKeyChecking=no darmawanjr88@34.101.205.217 &lt;&lt; EOF\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cd API-Registry\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; git pull origin main\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pm2 restart all\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EOF\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; '''\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n}\n</code></pre></div><p>The provided pipeline script is a clear example of how Jenkins orchestrates the CI/CD process, broken into multiple stages for ease of management. Let's break it down section by section and explain how each part works in a simplified, interactive way.</p><h3>Pipeline Declaration</h3><p>At the heart of any Jenkins pipeline is the pipeline block, which defines the entire process. Inside this block, the agent any directive tells Jenkins to run the pipeline on any available agent, whether it's a master or a worker node. This flexibility is useful when you have multiple agents configured and don’t want to restrict the execution to a specific one.</p><h3>Environment Variables</h3><p>Next, we have the environment block. This is where we can define variables that are reused across the pipeline. In this case, the variable GITHUB_CREDENTIALS holds the ID of the GitHub credentials that Jenkins uses to securely access the private repository. By defining it here, you ensure it’s easily reusable without hardcoding it into every step. Think of it as a centralized way to manage sensitive data like tokens and credentials, making the pipeline both secure and maintainable.</p><h3>Stages</h3><p>The pipeline is broken into logical steps called \"stages,\" each representing a part of the CI/CD workflow.</p><p>1. Git Checkout</p><p>In the first stage, Jenkins clones the GitHub repository using the git step. The credentialsId points to the pre-configured GitHub credentials stored in Jenkins. This ensures secure and seamless access to the private repository without exposing sensitive information. This step lays the foundation for the entire pipeline, as it fetches the code that the remaining stages will process.</p><p>2. Run Testing Commands</p><p>This stage is simple but powerful. It runs shell commands such as hostname and pwd, which output the hostname of the Jenkins agent and the current working directory, respectively. While these commands are placeholders here, you can replace them with actual test scripts. For instance, if you’re running unit tests, you could include a command like npm test or pytest. The purpose of this stage is to ensure the environment is configured correctly and ready for further operations.</p><p>3. Deploy to Server</p><p>This stage demonstrates how Jenkins can deploy your application to a production or staging server. Using the sshagent block, Jenkins securely connects to the target server via SSH. It then pulls the latest changes from the repository and restarts the application using PM2, a popular process manager for Node.js. This setup ensures that the application is always up-to-date with the latest code changes, and the restart command ensures a smooth rollout of updates.</p><p>Continuing from the previous explanation of setting up a Jenkins pipeline, the next step to truly automate the CI/CD process is to set up a <strong>push trigger</strong> using webhooks. This ensures that every time you push changes to your GitHub repository, Jenkins automatically triggers the pipeline, saving you from the hassle of manually starting the build.</p><p>Let’s explore how to set up a webhook-based trigger between GitHub and Jenkins in an intuitive and straightforward way.</p><h3><strong>What Are Webhooks?</strong></h3><p>Think of webhooks as a way for GitHub to \"talk\" to Jenkins. Whenever you push code to your repository, GitHub sends a signal (HTTP POST request) to Jenkins, telling it to start the pipeline. This creates an automated, real-time link between your code changes and the build process.</p><h3><strong>Setting Up Push Trigger (Webhook)</strong></h3><h4><strong>First, Enable GitHub Integration in Jenkins</strong></h4><p>Before setting up the webhook, you need to make sure Jenkins can communicate with GitHub. To do this, open Jenkins and go to <strong>Manage Jenkins</strong> &gt; <strong>Manage Plugins</strong>. From there, search for <strong>GitHub</strong> plugins and install them. This will allow Jenkins to recognize GitHub as a source and receive notifications from it.</p><h4><strong>Configure Jenkins to Listen for Webhooks</strong></h4><p>Next, open the Jenkins pipeline job you want to configure. In the job settings, go to <strong>Build Triggers</strong> and enable the option <strong>GitHub hook trigger for GITScm polling</strong>. This step is important because it tells Jenkins to \"listen\" for any push events from GitHub, ready to trigger the pipeline whenever changes are detected.</p><h4><strong>Set Up a Webhook in GitHub</strong></h4><p>Now, head over to your GitHub repository. Inside the <strong>Settings</strong> tab, navigate to <strong>Webhooks</strong> and click on <strong>Add webhook</strong>. You'll need to provide Jenkins with a specific endpoint where it can receive notifications from GitHub. The URL format is as follows:</p><div><pre><code>http://&lt;JENKINS_URL&gt;/github-webhook/\n</code></pre></div><p>Replace <strong><em>JENKINS_URL </em></strong>with your Jenkins server’s address. Choose <strong>application/json</strong> as the content type, and make sure the <strong>Push events</strong> option is selected. This ensures that the webhook triggers every time you push changes.</p><h4><strong>Verify the Webhook</strong></h4><p>Once everything is set up, push a commit to your GitHub repository. Then, return to Jenkins and check if the pipeline starts running automatically. If the job kicks off, the webhook is working properly.</p><h3><strong>How It All Comes Together</strong></h3><p>When you push changes to your repository, GitHub sends a webhook to Jenkins. Jenkins then triggers the pipeline to fetch the latest code, run tests, and deploy to your server. This creates a seamless CI/CD process, where every change is automatically tested and deployed.</p><h1><strong>Conclusion</strong></h1><p>In this Labs, we’ve taken a deep dive into how Jenkins can supercharge your CI/CD workflows, making it an essential tool for automating your development lifecycle. We started by setting up Jenkins, installing necessary dependencies like Java, and getting the Jenkins service up and running.</p><p>From there, we explored how to configure Jenkins to work with your GitHub repository, including managing credentials securely. With Jenkins set up and connected to GitHub, we moved on to creating a simple declarative pipeline, allowing Jenkins to automatically fetch the latest code, run tests, and deploy to your server.</p><p>We then enhanced the process by explaining how to set up push triggers using GitHub webhooks. With webhooks in place, Jenkins is able to automatically start the pipeline whenever new code is pushed to the repository, eliminating the need for manual intervention and ensuring continuous integration.</p><p>Through these steps, we’ve created a fully automated CI/CD pipeline that reacts to changes in your code, testing it and deploying it seamlessly. This not only saves time but also minimizes errors, providing faster and more reliable software delivery.</p><p>By mastering Jenkins, you’re empowering yourself to automate complex workflows, improve collaboration, and focus on building great software without worrying about the manual process of integration and deployment.</p>","timestamp":"Monday, January 6, 2025 at 12:32:13 PM GMT+8","image":"https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2Fjenkins_background.png?alt=media&token=8d8f21c7-f6bd-4157-8343-12090e88d13a","image_alt":"Jenkins Intro image","slug":"Jenkins-Unleashed-Transforming-Your-CICD-Workflow-for-Lightning-Fast-Delivery","index":"6b86b273ff34f","tags":["CI/CD","System Design"]},"recommendedPosts":[{"blog_id":"4400b3a0-4d34-4185-806a-f265089e8af8","title":"MySQL Migration with Connection Pooling: A Simple Guide","short_description":"Imagine standing in line at a coffee shop where each customer needs to fill out a membership form before ordering and then tears it up after getting their coffee. Sounds inefficient, right? This is exactly what happens when your application connects to a database without connection pooling.","timestamp":"2025-04-28 11:49:06","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1745838714722_connection%20pool%20Bg.png","image_alt":"Connection Pool Labs Content","slug":"MySQL-Migration-with-Connection-Pooling-A-Simple-Guide-1","index":"d4735e3a265e1","tags":["System Design","Database","Software Architecture","Cloud Computing"]},{"blog_id":"6234fef8-1547-46f7-ae10-33d577a1d168","title":"Understanding RabbitMQ: A Favorite Simple Messaging Service!","short_description":"RabbitMQ is a robust, open-source message broker that facilitates communication between applications by sending and receiving messages. Whether you're building a microservices architecture or a distributed system, RabbitMQ ensures reliable, scalable, and asynchronous messaging. In this blog, we’ll walk through its core components and concepts, from producers to consumers, and dive into some advanced features like round-robin dispatching and virtual hosts.","timestamp":"2025-03-15 19:44:13","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1742090540692_rabbitmq.webp","image_alt":"rabbit mq","slug":"Understanding-RabbitMQ-A-Favorite-Simple-Messaging-Service","index":"6b86b273ff34f","tags":["Message Broker","System Design","Software Architecture"]},{"blog_id":"86f7440f-033f-4459-b0a5-09f74d7c34ba","title":"Understanding Circuit Breakers in Software Engineering: From Traditional to Serverless","short_description":"Imagine you’re using electricity at home, and a short circuit occurs. The circuit breaker in your electrical panel cuts the power to prevent a fire. In software, the concept is similar: it’s a design pattern that protects your system from repeated failures when calling external services","timestamp":"2025-03-14 02:46:27","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1741948558177_circuit_breaker.png","image_alt":"Circuit breaker","slug":"Understanding-Circuit-Breakers-in-Software-Engineering-From-Traditional-to-Serverless","index":"6b86b273ff34f","tags":["System Design","Software Architecture"]}]},"__N_SSG":true}