{"pageProps":{"article":{"blog_id":"e7d3943c-c12a-42c1-9663-2d90449138dc","title":"The concept of splitting a frontend into smaller, manageable pieces.","short_description":"Have you ever worked on a massive frontend application where every change felt risky and deploying updates took ages? If so, micro frontends might be the solution you’ve been looking for","description":"<p>Micro frontends are an architectural approach that applies the principles of microservices to frontend development. Instead of building a single, monolithic frontend application, the user interface is divided into smaller, independent pieces called <strong>micro frontends</strong>, each of which is developed, deployed, and maintained independently.</p><h1><strong>The Problem with Monolithic Frontends</strong></h1><p>A <strong>monolithic frontend</strong> refers to a single, large codebase that manages the entire user interface of an application. While this approach works well for small applications, it becomes increasingly challenging to manage and scale as the application and development teams grow. Below are the key problems associated with monolithic frontends:</p><h2><strong>1. Scaling Teams</strong></h2><ul><li><strong>Coordination Overhead</strong>: In a large team, multiple developers work on the same codebase. This can lead to frequent merge conflicts, delayed pull requests, and dependency issues.</li><li><strong>Limited Parallel Development</strong>: Because the codebase is tightly coupled, teams cannot work independently on different parts of the application without stepping on each other's toes.</li></ul><h2><strong>2. Slower Development Cycles</strong></h2><ul><li><strong>Single Deployment Pipeline</strong>: In a monolithic frontend, all changes must pass through the same build and deployment pipeline. This means Small changes (e.g., fixing a typo) require deploying the entire application, also A single bug can block the entire release process.</li><li><strong>Longer Testing Time</strong>: The larger the application, the more time and effort it takes to ensure that new changes don’t break existing functionality.</li></ul><h2><strong>3. High Risk of Changes</strong></h2><ul><li><strong>Ripple Effect</strong>: Since everything is interconnected, even small changes in one part of the application can have unintended consequences elsewhere.</li><li><strong>Rollback Challenges</strong>: If something goes wrong after deployment, rolling back requires reverting the entire application, not just the problematic component.</li></ul><h2><strong>4. Tech Stack Lock-In</strong></h2><ul><li><strong>Difficult to Adopt New Frameworks</strong>: In a monolithic frontend, the entire application is built using a single framework or library. Upgrading or switching technologies is a monumental task that may require rewriting the entire application. <strong>Example</strong>: Migrating from AngularJS to React would involve significant effort and downtime.</li><li><strong>No Flexibility for Teams</strong>: Teams must stick to the same tech stack, even if certain parts of the application would benefit from newer or more suitable tools.</li></ul><h1><strong>How Micro Frontends Work</strong></h1><p>Micro frontends operate on the principle of <strong>divide and conquer</strong>. Instead of managing one gigantic codebase, you divide your application into smaller units.</p><p>The idea behind micro frontends is simple yet powerful:</p><p><strong>1. Divide</strong> your application into smaller, self-contained pieces.</p><p><strong>2. Conquer</strong> by developing, testing, and deploying these pieces independently.</p><p>Instead of one massive codebase where every change has the potential to disrupt the entire application, you get a collection of smaller, focused units that can evolve at their own pace. Here is the breakdown of how divide and conquer works in microfrontend.</p><p><br></p><p><img src=\"https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2Fmonolit_vs_microfrontend.png?alt=media&amp;token=24eba3d8-b7f3-4674-b33e-62daf0517afd\" alt=\"Monolithic Vs Microfrontend\" width=\"720px\"></p><p><br></p><p>In a traditional monolithic architecture (left side), all components of a web application are tightly coupled and deployed as a single unit. This includes the web application layer (frontend), integration layer (APIs), and service layer (backend).</p><p>Microfrontends (right side) break down a large web application into smaller, independent frontend applications (also called \"micro-applications\" or \"micro-frontends\"). Each microfrontend is responsible for a specific feature or section of the application. This approach promotes modularity, scalability, and faster development cycles.</p><p>The divide and conquer approach is central to microfrontends. It involves:</p><h3><strong>Dividing the Application:</strong></h3><ol><li><strong>Identify Features:</strong> First, break down the application into distinct features or sections. For example, in the image, we have \"Cart,\" \"Website,\" and \"Payment\" as separate features.</li><li><strong>Assign Teams:</strong> Each feature is assigned to an independent team. This allows teams to work autonomously, focusing on their specific feature.</li></ol><h3><strong>Conquering the Features:</strong></h3><ol><li><strong>Independent Development:</strong> Each team develops its feature as a standalone frontend application. They can use different technologies (React, JAML, etc.) and frameworks as needed.</li><li><strong>API Integration:</strong> Teams define clear APIs for their microfrontends to communicate with each other and with the backend services. This ensures loose coupling and flexibility.</li></ol><h3><strong>Composition and Orchestration:</strong></h3><ol><li><strong>Frameworks and Tools:</strong> A framework or library is used to combine the microfrontends into a cohesive user experience. This can be done using techniques like server-side composition (e.g., with a Node.js server) or client-side composition (e.g., with a JavaScript framework like Single-SPA).</li><li><strong>Routing and Navigation:</strong> The framework handles routing and navigation between microfrontends, ensuring a seamless user experience.</li><li><strong>Shared Components:</strong> If necessary, shared components can be developed and used across multiple microfrontends. This promotes consistency and reduces code duplication.</li></ol><h1>Conclusion</h1><p>Micro frontends represent a modern approach to building scalable, resilient, and maintainable frontend applications. By breaking down your application into smaller, independent pieces, you empower your teams to innovate faster and reduce deployment risks.. If you’ve ever felt constrained by the limitations of a monolithic frontend, it might be time to explore the possibilities of micro frontends. They’re not just a technical solution—they’re a way to rethink how we build for the web.</p>","timestamp":"Wednesday, December 4, 2024 at 11:23:45 AM GMT+8","image":"https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2Fmicrofrontend.webp?alt=media&token=6274c176-9622-4cd5-93be-9ea9e5912bd9","image_alt":"Microfrontend Image Cover","slug":"the-concept-of-splitting-a-frontend-into-smaller-manageable-pieces","index":"6b86b273ff34f","tags":["Frontend","Software Architecture","System Design"]},"recommendedPosts":[{"blog_id":"4400b3a0-4d34-4185-806a-f265089e8af8","title":"MySQL Migration with Connection Pooling: A Simple Guide","short_description":"Imagine standing in line at a coffee shop where each customer needs to fill out a membership form before ordering and then tears it up after getting their coffee. Sounds inefficient, right? This is exactly what happens when your application connects to a database without connection pooling.","timestamp":"2025-04-28 11:49:06","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1745838714722_connection%20pool%20Bg.png","image_alt":"Connection Pool Labs Content","slug":"MySQL-Migration-with-Connection-Pooling-A-Simple-Guide-1","index":"d4735e3a265e1","tags":["System Design","Database","Software Architecture","Cloud Computing"]},{"blog_id":"6234fef8-1547-46f7-ae10-33d577a1d168","title":"Understanding RabbitMQ: A Favorite Simple Messaging Service!","short_description":"RabbitMQ is a robust, open-source message broker that facilitates communication between applications by sending and receiving messages. Whether you're building a microservices architecture or a distributed system, RabbitMQ ensures reliable, scalable, and asynchronous messaging. In this blog, we’ll walk through its core components and concepts, from producers to consumers, and dive into some advanced features like round-robin dispatching and virtual hosts.","timestamp":"2025-03-15 19:44:13","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1742090540692_rabbitmq.webp","image_alt":"rabbit mq","slug":"Understanding-RabbitMQ-A-Favorite-Simple-Messaging-Service","index":"6b86b273ff34f","tags":["Message Broker","System Design","Software Architecture"]},{"blog_id":"86f7440f-033f-4459-b0a5-09f74d7c34ba","title":"Understanding Circuit Breakers in Software Engineering: From Traditional to Serverless","short_description":"Imagine you’re using electricity at home, and a short circuit occurs. The circuit breaker in your electrical panel cuts the power to prevent a fire. In software, the concept is similar: it’s a design pattern that protects your system from repeated failures when calling external services","timestamp":"2025-03-14 02:46:27","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1741948558177_circuit_breaker.png","image_alt":"Circuit breaker","slug":"Understanding-Circuit-Breakers-in-Software-Engineering-From-Traditional-to-Serverless","index":"6b86b273ff34f","tags":["System Design","Software Architecture"]}]},"__N_SSG":true}