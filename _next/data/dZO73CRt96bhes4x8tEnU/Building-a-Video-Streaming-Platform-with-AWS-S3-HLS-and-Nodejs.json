{"pageProps":{"article":{"blog_id":"3b169c47-8359-4743-9dd2-eebbb68e0c52","title":"Building a Video Streaming Platform with AWS S3, HLS, and Node.js","short_description":"Ever wondered how your favorite streaming platforms deliver smooth, high-quality videos? Streaming video content is a cornerstone of modern web applications. Let’s explore how to build a video streaming service step by step.","description":"<p>By the end of this guide, you'll have the skills to:</p><p>- Store video chunks securely in AWS S3.</p><p>- Stream videos dynamically to users using HLS.</p><p>- Enable users to upload videos, automatically process them into HLS chunks, and store them in S3.</p><p><strong>Ready to get started? Let's dive in!</strong></p><h1><strong>Step 1: Storing Video Chunks in AWS S3</strong></h1><p>To stream videos, we first need to upload .ts (MPEG transport stream) files and a .m3u8 playlist to an AWS S3 bucket. Follow these steps to upload your files:</p><h3>Why AWS S3?</h3><p>AWS S3 provides a scalable, reliable, and secure storage solution, making it perfect for handling large video files. Using the AWS CLI simplifies the upload process and integrates easily into automation pipelines.</p><h3>Step-by-Step Instructions:</h3><p>1. Open your terminal.</p><p>2. Run the following commands to upload the video chunks and playlist:</p><div><pre><code>aws s3 cp output0.ts s3://your-bucket-name/path-to-folder/\naws s3 cp playlist.m3u8 s3://your-bucket-name/path-to-folder/\n</code></pre></div><p>While we’re using the AWS CLI here, you could also use the AWS Management Console or SDKs (e.g., AWS SDK for JavaScript) if you prefer a graphical interface or code-based interaction.</p><p>Once uploaded, your files will be securely stored and accessible for streaming. Let’s move to setting up the backend!</p><h1><strong>Step 2: Streaming the Video with Express.js</strong></h1><p>Now that our video chunks are in S3, we need a backend to fetch and serve them to the client. We’ll use Node.js with Express.js to handle this.</p><h3>Backend Setup:</h3><p>1. Create a new Node.js project and install the necessary packages:</p><div><pre><code>npm init -y\nnpm install express @aws-sdk/client-s3\n</code></pre></div><p>2. Add the following code to your server.js file: </p><div><pre><code>import express from 'express';\nimport { S3Client, GetObjectCommand } from '@aws-sdk/client-s3';\nimport stream from 'stream';\n\nconst app = express();\nconst s3 = new S3Client({ region: 'your-region' });\n\n// Endpoint to serve the HLS playlist\napp.get('/play/playlist.m3u8', async (req, res) =&gt; {\n&nbsp;&nbsp;try {\n&nbsp;&nbsp;&nbsp;&nbsp;const command = new GetObjectCommand({\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bucket: 'your-bucket-name',\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key: 'path-to-folder/playlist.m3u8',\n&nbsp;&nbsp;&nbsp;&nbsp;});\n&nbsp;&nbsp;&nbsp;&nbsp;const s3Response = await s3.send(command);\n&nbsp;&nbsp;&nbsp;&nbsp;s3Response.Body.pipe(res);\n&nbsp;&nbsp;} catch (err) {\n&nbsp;&nbsp;&nbsp;&nbsp;console.error('Error fetching playlist:', err);\n&nbsp;&nbsp;&nbsp;&nbsp;res.status(500).send('Error fetching playlist');\n&nbsp;&nbsp;}\n});\n\n// Endpoint to serve video chunks\napp.get('/play/video/:segment', async (req, res) =&gt; {\n&nbsp;&nbsp;try {\n&nbsp;&nbsp;&nbsp;&nbsp;const command = new GetObjectCommand({\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bucket: 'your-bucket-name',\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key: `path-to-folder/${req.params.segment}`,\n&nbsp;&nbsp;&nbsp;&nbsp;});\n&nbsp;&nbsp;&nbsp;&nbsp;const s3Response = await s3.send(command);\n&nbsp;&nbsp;&nbsp;&nbsp;s3Response.Body.pipe(res);\n&nbsp;&nbsp;} catch (err) {\n&nbsp;&nbsp;&nbsp;&nbsp;console.error('Error fetching video segment:', err);\n&nbsp;&nbsp;&nbsp;&nbsp;res.status(500).send('Error fetching video segment');\n&nbsp;&nbsp;}\n});\n\nconst PORT = 3000;\napp.listen(PORT, () =&gt; {\n&nbsp;&nbsp;console.log(`Server is running on http://localhost:${PORT}`);\n});\n</code></pre></div><h3>What’s Happening Here?</h3><p><strong>- Playlist Endpoint</strong>: Fetches and streams the .m3u8 file from S3.</p><p><strong>- Video Chunks Endpoint</strong>: Dynamically fetches .ts chunks based on the client’s request.</p><p>Once the backend is running, we can serve video content to the client. Let’s bring it all together on the frontend.</p><h1><strong>Step 3: Playing the Video on the Client-Side</strong></h1><p>To play the HLS video stream in the browser, we’ll use the <code>&lt;video&gt;</code> HTML tag and the HLS.js library for compatibility with all modern browsers.</p><h3>Implementation:</h3><p>1. Create an index.html file with the following content:</p><div><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n&nbsp;&lt;meta charset=\"UTF-8\"&gt;\n&nbsp;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n&nbsp;&lt;title&gt;Video Streaming&lt;/title&gt;\n&nbsp;&lt;script src=\"https://cdn.jsdelivr.net/npm/hls.js@latest\"&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&nbsp;&lt;h1&gt;Video Streaming Example&lt;/h1&gt;\n&nbsp;&lt;video id=\"videoPlayer\" controls width=\"720\" autoplay&gt;&lt;/video&gt;\n\n&nbsp;&lt;script&gt;\n&nbsp;&nbsp;const video = document.getElementById('videoPlayer');\n&nbsp;&nbsp;const videoSrc = 'http://localhost:3000/play/playlist.m3u8';\n\n&nbsp;&nbsp;if (Hls.isSupported()) {\n&nbsp;&nbsp;&nbsp;const hls = new Hls();\n&nbsp;&nbsp;&nbsp;hls.loadSource(videoSrc);\n&nbsp;&nbsp;&nbsp;hls.attachMedia(video);\n&nbsp;&nbsp;} else if (video.canPlayType('application/vnd.apple.mpegurl')) {\n&nbsp;&nbsp;&nbsp;video.src = videoSrc;\n&nbsp;&nbsp;} else {\n&nbsp;&nbsp;&nbsp;console.error('This browser does not support HLS streaming');\n&nbsp;&nbsp;}\n&nbsp;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre></div><h3>Key Points:</h3><p>- The browser fetches the <code>.m3u8</code> playlist, which directs it to download the <code>.ts</code> chunks for smooth playback.</p><p>- The HLS.js library ensures compatibility with browsers that don’t natively support HLS.</p><p>Now you have a working video player! Let’s take it a step further by allowing users to upload videos.</p><h1><strong>Step 4: Allowing Users to Upload Videos</strong></h1><p>What if users want to upload their own videos? We can process those videos into HLS chunks and store them in S3.</p><h3>Backend for Uploading and Processing:</h3><p>1. Install the required packages:</p><div><pre><code>npm install multer fluent-ffmpeg\n</code></pre></div><p>2. Update your server.js file with the following:</p><div><pre><code>import multer from 'multer';\nimport ffmpeg from 'fluent-ffmpeg';\nimport { PutObjectCommand } from '@aws-sdk/client-s3';\nimport fs from 'fs';\n\nconst upload = multer({ dest: 'uploads/' });\n\napp.post('/upload', upload.single('video'), (req, res) =&gt; {\n&nbsp;&nbsp;const inputPath = req.file.path;\n&nbsp;&nbsp;const outputPath = 'processed/';\n\n&nbsp;&nbsp;ffmpeg(inputPath)\n&nbsp;&nbsp;&nbsp;&nbsp;.output(`${outputPath}playlist.m3u8`)\n&nbsp;&nbsp;&nbsp;&nbsp;.outputOptions([\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'-hls_time 10',\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'-hls_list_size 0',\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'-f hls',\n&nbsp;&nbsp;&nbsp;&nbsp;])\n&nbsp;&nbsp;&nbsp;&nbsp;.on('end', async () =&gt; {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Upload .m3u8 and .ts files to S3\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const filesToUpload = fs.readdirSync(outputPath);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (const file of filesToUpload) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const command = new PutObjectCommand({\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bucket: 'your-bucket-name',\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key: `path-to-folder/${file}`,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Body: fs.createReadStream(`${outputPath}${file}`),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await s3.send(command);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res.send('Video uploaded and processed successfully!');\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (err) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error('Error uploading to S3:', err);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res.status(500).send('Error uploading video.');\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;})\n&nbsp;&nbsp;&nbsp;&nbsp;.on('error', (err) =&gt; {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.error('Error processing video:', err);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res.status(500).send('Error processing video.');\n&nbsp;&nbsp;&nbsp;&nbsp;})\n&nbsp;&nbsp;&nbsp;&nbsp;.run();\n});\n</code></pre></div><h3>Workflow:</h3><p>1. Users upload a video via the /upload endpoint.</p><p>2. FFmpeg processes the video into HLS chunks.</p><p>3. The processed files are automatically uploaded to S3.</p><h1><strong>Final Thoughts</strong></h1><p>Congratulations! You’ve built a fully functional video streaming platform. Here's a recap of what we accomplished:</p><p><strong>- Secure Storage</strong>: Used AWS S3 for reliable and scalable storage.</p><p><strong>- Seamless Streaming</strong>: Enabled dynamic streaming with HLS.</p><p><strong>- User Uploads</strong>: Automated video processing and storage with FFmpeg and Node.js.</p><p>This architecture is scalable and can serve as the foundation</p>","timestamp":"Sunday, December 15, 2024 at 10:42:44 AM GMT+8","image":"https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2FHLS-IMAGE.jpg?alt=media&token=8077c433-3d64-4627-86d5-e9605a6aa9a2","image_alt":"HLS background","slug":"Building-a-Video-Streaming-Platform-with-AWS-S3-HLS-and-Nodejs","index":"6b86b273ff34f","tags":["Storage","API","Node.Js","Cloud Computing"]},"recommendedPosts":[{"blog_id":"4400b3a0-4d34-4185-806a-f265089e8af8","title":"MySQL Migration with Connection Pooling: A Simple Guide","short_description":"Imagine standing in line at a coffee shop where each customer needs to fill out a membership form before ordering and then tears it up after getting their coffee. Sounds inefficient, right? This is exactly what happens when your application connects to a database without connection pooling.","timestamp":"2025-04-28 11:49:06","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1745838714722_connection%20pool%20Bg.png","image_alt":"Connection Pool Labs Content","slug":"MySQL-Migration-with-Connection-Pooling-A-Simple-Guide-1","index":"d4735e3a265e1","tags":["System Design","Database","Software Architecture","Cloud Computing"]},{"blog_id":"52eb37c3-83bc-4442-a8c5-305bfba74e62","title":"Why API Versioning is Really Important: A Lesson from My Own Mistake","short_description":"As a developer, I've built countless APIs for my personal projects. Some were experimental, some turned into full-fledged applications, and others were simply abandoned over time. At first, managing these APIs felt simple—if I wasn't using an endpoint anymore, I would just delete it. Why keep something that I no longer need, right?  Well, that mindset came back to bite me.","timestamp":"2025-02-16 05:35:40","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1739712690763_api-versioning-strategy.jpg","image_alt":"Api Versioning","slug":"Why-API-Versioning-is-Really-Important-A-Lesson-from-My-Own-Mistake","index":"6b86b273ff34f","tags":["API"]},{"blog_id":"911a9001-3c3e-4f2c-aa83-4ec4f6f71c99","title":"Terraform Labs: Automating Google Cloud Infrastructure Deployment","short_description":"Manually managing cloud infrastructure can be time-consuming and error-prone. Terraform changes the game by allowing you to define infrastructure as code, making deployment faster, scalable, and repeatable. With Terraform, you can automate cloud resource creation, track changes, and collaborate effortlessly.","timestamp":"2025-02-15 18:15:22","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1739669992396_gcp-terraform.png","image_alt":"Terraform with GCP","slug":"Terraform-Labs-Automating-Google-Cloud-Infrastructure-Deployment","index":"6b86b273ff34f","tags":["Software Architecture","Cloud Computing"]}]},"__N_SSG":true}