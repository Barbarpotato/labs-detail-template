{"pageProps":{"article":{"blog_id":"82db10ae-f820-45d6-b985-9ac22fa7046f","title":"Create GRPC With MongoDB & Node.js","short_description":"We will explore about the grpc, which is the better version of the basic HTTP1.1 and make communications more faster between client-server","description":"<div id=\"content-1\"><h1>What is GRPC?</h1><p>gRPC (Google Remote Procedure Call) is a high-performance, open-source framework developed by Google that enables efficient communication between distributed systems using remote procedure calls (RPCs). It leverages HTTP/2 for transport, Protocol Buffers (protobuf) for serialization, and supports features like multiplexing, streaming, and low-latency communication, making it ideal for modern microservices architectures and real-time applications. gRPC is increasingly used in this era due to its ability to handle complex, high-throughput workloads while ensuring consistent, language-agnostic communication between services, which is crucial for building scalable, resilient, and performant systems.</p><p>gRPC is highly relevant today due to its efficient communication using Protocol Buffers for serialization, which reduces message sizes and improves performance. It leverages HTTP/2 for lower latency and higher throughput, supports multiple programming languages, and provides strongly typed contracts for consistency. With built-in support for streaming, SSL/TLS for security, and automatic code generation, gRPC enhances development speed and ensures secure, real-time communication. Its compatibility with cloud-native platforms and microservices architectures further makes it a valuable tool for modern distributed systems.</p></div><div id=\"content-2\"><img style='width:720px;' src='https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2Fgrpc_architecture.png?alt=media&token=fff5674e-8a0b-4e46-805d-feed5b3cf0f5'/></div><div id=\"content-4\"><p>The basic architecture of gRPC involves several key components that facilitate communication between a client and server. Here's a breakdown of the architecture:</p><h3>1.&nbsp;<strong>Protocol Buffers (Protobufs):</strong></h3><ul><li><strong>Definition Language</strong>: Protobufs are used to define the service methods and message types. These definitions are stored in&nbsp;<code>.proto</code>&nbsp;files.</li><li><strong>Serialization</strong>: Protobufs serialize data into a compact binary format, which is efficient for transmission.</li></ul><h3>2.&nbsp;<strong>Service Definition:</strong></h3><ul><li><strong>Service Interface</strong>: In the&nbsp;<code>.proto</code>&nbsp;file, services are defined with methods that can be called remotely by clients. Each method specifies the request and response message types.</li></ul><h3>3.&nbsp;<strong>Code Generation:</strong></h3><ul><li><strong>Client and Server Stubs</strong>: The&nbsp;<code>.proto</code>&nbsp;file is used to generate client and server code in various languages. These stubs handle the serialization and deserialization of messages and the underlying gRPC protocol details.</li></ul><h3>4.&nbsp;<strong>Client-Side:</strong></h3><ul><li><strong>Stub</strong>: The client uses a generated stub to invoke methods on the server. The stub provides a local representation of the remote service.</li><li><strong>Channel</strong>: The client creates a communication channel to the server, which manages the connection and handles the low-level details of the communication.</li></ul><h3>5.&nbsp;<strong>Server-Side:</strong></h3><ul><li><strong>Implementation</strong>: The server implements the service methods defined in the&nbsp;<code>.proto</code>&nbsp;file. These methods process incoming requests and generate responses.</li><li><strong>Server</strong>: The server listens for incoming requests, dispatches them to the appropriate service method implementations, and sends back responses.</li></ul><h3>6.&nbsp;<strong>Communication:</strong></h3><ul><li><strong>HTTP/2</strong>: gRPC uses HTTP/2 as the transport protocol, providing features like multiplexing, flow control, and header compression.</li><li><strong>Streams</strong>: gRPC supports different types of RPCs, including unary (single request/response), server streaming, client streaming, and bidirectional streaming.</li></ul></div><div id=\"content-5\"><h1>Basic gRPC Workflow:</h1><ol><li><strong>Define the Service</strong>: Create a <code>.proto</code> file with service and message definitions.</li><li><strong>Generate Code</strong>: Use the <code>protoc</code> compiler to generate client and server code from the <code>.proto</code> file.</li><li><strong>Implement the Server</strong>: Write the server-side code to implement the service methods.</li><li><strong>Create the Client</strong>: Write the client-side code to call the service methods using the generated stub.</li><li><strong>Establish Communication</strong>: The client and server communicate over a channel using HTTP/2, with data serialized and deserialized using Protobufs.</li></ol></div><div id=\"content-8\"><h3>In gRPC, the client can indeed send data to the server. gRPC supports several types of communication patterns, including:</h3><h3>1. Unary RPC:</h3><ul><li>The client sends a single request to the server and receives a single response.</li></ul></div><div id=\"content-9\"><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\">rpc SayHello (HelloRequest) returns (HelloReply) {}</code></pre></div><div id=\"content-10\"><h3>2. Server Streaming RPC:</h3><ul><li>The client sends a single request to the server and receives a stream of responses.</li></ul></div><div id=\"content-11\"><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\">rpc ListFeatures (Rectangle) returns (stream Feature) {}</code></pre></div><div id=\"content-12\"><h3>3. Client Streaming RPC:</h3><ul><li>The client sends a stream of requests to the server and receives a single response.</li></ul></div><div id=\"content-13\"><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\">rpc RecordRoute (stream Point) returns (RouteSummary) {}</code></pre></div><div id=\"content-14\"><h3>4. Bidirectional Streaming RPC:</h3><ul><li>Both the client and server send a stream of messages to each other.</li></ul></div><div id=\"content-15\"><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\">rpc RouteChat (stream RouteNote) returns (stream RouteNote) {}</code></pre></div><div id=\"content-16\"><h1>Example</h1></div><div id=\"content-19\"><p>Let's try to do the key list that we define in above. in this example we are going to implement the unary RPC for the sake of the simplicity. and in this example we are going to implement the grpc within the node.js with the helper of our beloved database called MongoDb. for this example what we are going to achieve is the client side can search the book data from the mongodb database. To ensure that the client can get the data successfully, the client side need to get interact with our grpc server. in a nutshell, the server side grpc will serve the client side. To create a gRPC server in Node.js, we need to install the required packages:</p></div><div id=\"content-20\"><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\">npm install @grpc/grpc-js @grpc/proto-loader\n</code></pre></div><div id=\"content-21\"><p>after the installation is complete, we then create a proto file. in this file we define the service and the message that we are going to build. here is the example code:</p></div><div id=\"content-22\"><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\">syntax = \"proto3\";\n\nservice Book {\n  rpc GetBook (GetBookRequest) returns (BookReply) {}\n}\n\nmessage GetBookRequest {\n  string Title = 1;\n}\n\nmessage BookReply {\n  string Title = 1;\n  string Author = 2;\n  int32 Published = 3;\n  string Language = 4;\n  string Id = 5;\n  int32 Sales = 6;\n}</code></pre></div><div id=\"content-23\"><p>the proto file is ready. now we can load it up trough our core script to running our node server. dont forget that we are using the mongodb database. so the first step is to setup the connection between the mongodb and the server, and then we build up the grpc service in a top of mongodb service.</p></div><div id=\"content-32\"><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\">const grpc = require('@grpc/grpc-js');\nconst protoLoader = require('@grpc/proto-loader');\nconst path = require('path');\nconst { MongoClient } = require('mongodb');\n\n// Load the protobuf file\nconst PROTO_PATH = path.resolve(__dirname, 'service.proto');\nconst packageDefinition = protoLoader.loadSync(PROTO_PATH);\nconst proto = grpc.loadPackageDefinition(packageDefinition);\n\n// MongoDB connection URL and Database name\nconst url = 'mongodb://localhost:27017';\nconst dbName = 'Book';\n\nlet db;\nlet client;\n\n// Connect to MongoDB and start gRPC server\nasync function main() {\n    const client = new MongoClient(url);\n\n    try {\n        await client.connect();\n        console.log('Connected to MongoDB');\n        db = client.db(dbName);\n\n        // Start gRPC server after MongoDB connection\n        startGrpcServer();\n    } catch (e) {\n        console.error('Failed to connect to MongoDB', e);\n    } finally {\n        // Ensure MongoClient is closed if needed\n        // Uncomment if you need to close the client here:\n        // await client.close();\n    }\n}\n\n\n// gRPC service method\nfunction GetBook(call, callback) {\n    console.log('Received request:', call.request);\n    const { Title } = call.request;\n    const collection = db.collection('list');\n\n    console.log('Performing findOne query with Book:', Title);\n    collection.findOne({ Book: Title }, { maxTimeMS: 5000 })\n        .then(result =&gt; {\n            console.log('findOne query completed');\n            if (result) {\n                const response = {\n                    Title: result.Book,\n                    Author: result['Author(s)'], // Adjusted field names\n                    Published: result['First published'],\n                    Language: result['Original language'],\n                    Id: result._id.toString(),\n                    Sales: result['Approximate sales in millions']\n                };\n                console.log('Sending response:', response);\n                callback(null, response);\n            } else {\n                console.log('Book not found');\n                callback(null, { Title: \"Book not found\" });\n            }\n        })\n        .catch(err =&gt; {\n            console.error('Error fetching data:', err);\n            callback(err, null);\n        });\n}\n\n\n// Start the gRPC server\nfunction startGrpcServer() {\n    const server = new grpc.Server();\n    server.addService(proto.Book.service, { GetBook: GetBook });\n    const port = '50051';\n    server.bindAsync(`0.0.0.0:${port}`, grpc.ServerCredentials.createInsecure(), (error, port) =&gt; {\n        if (error) {\n            console.error(`Failed to bind server: ${error.message}`);\n            process.exit(1); // Exit process if server fails to start\n        }\n        console.log(`Server running at http://0.0.0.0:${port}`);\n    });\n}\n\n// Run the main function\nmain();</code></pre></div><div id=\"content-33\"><p>We can now run the server. by using the command node &lt;the name of your server code file&gt;</p></div><div id=\"content-34\"><img style='width:720px;' src='https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2Fgrpc-step-1.png?alt=media&token=cef277a6-d5e2-45d9-80f2-6871e3715089'/></div><div id=\"content-35\"><p>The setup and implementation of the server.js is completed. now we move to the code of the client side. which is more simple. here is the code to call the available service from the server side that we implement previously. where in here we can access the GetBook service. and try to search the field named book with value&nbsp;Where the Crawdads Sing</p></div><div id=\"content-36\"><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\">const grpc = require('@grpc/grpc-js');\nconst protoLoader = require('@grpc/proto-loader');\nconst path = require('path');\n\n// Load the protobuf file\nconst PROTO_PATH = path.resolve(__dirname, 'service.proto');\nconst packageDefinition = protoLoader.loadSync(PROTO_PATH);\nconst proto = grpc.loadPackageDefinition(packageDefinition);\n\n// Create a new gRPC client\nconst client = new proto.Book('localhost:50051', grpc.credentials.createInsecure());\n\n// Call the service\nclient.GetBook({ Title: 'Where the Crawdads Sing' }, (error, response) =&gt; {\n    if (error) {\n        console.error(`Error: ${error.message}`);\n    } else {\n        console.log(`Response: ${JSON.stringify(response)}`);\n    }\n});\n</code></pre></div><div id=\"content-37\"><p>We can run this client side. and it the result of the book that we search is delivered to the client side.</p></div><div id=\"content-38\"><img style='width:720px;' src='https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2Fgrpc-step-2.png?alt=media&token=85d657cc-6260-492d-a70e-62d26b038da2'/></div><div id=\"content-40\"><h1>Conclusion</h1><p>gRPC is a powerful framework for building efficient, high-performance communication between distributed systems. By leveraging HTTP/2 and Protocol Buffers (protobuf), gRPC enables low-latency, scalable interactions ideal for microservices and real-time applications. In this example, we demonstrated how to set up a gRPC server in Node.js that interacts with a MongoDB database. We defined a service using Protocol Buffers, implemented the server to handle requests, and created a client to query book data. This approach allows for efficient data retrieval and robust communication between client and server, showcasing gRPC's capabilities in modern software development. By understanding gRPC's architecture and workflow, and implementing it in a real-world scenario, you can build scalable, high-performance systems that handle complex workloads with ease.</p></div>","timestamp":"Friday, September 20, 2024 at 11:34:55 AM GMT+8","image":"https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2Fgrpc_background.png?alt=media&token=3df4f4c7-ea5f-4170-ae16-6656671bfd4a","image_alt":"GRPC Background","slug":"create-grpc-with-mongodb--nodejs","index":"6b86b273ff34f","tags":["Node.Js","NO SQL","Backend"]},"recommendedPosts":[{"blog_id":"19882a74-d1c2-4b31-837e-99cdc1846fcf","title":"Apache Cassandra: The NoSQL Powerhouse","short_description":"In today's world of big data, scalability and performance are crucial. Apache Cassandra, an open-source NoSQL database, is a top choice for handling large-scale, distributed data. Used by giants like Facebook, Netflix, and Twitter, Cassandra offers high availability, fault tolerance, and seamless scalability. Let’s dive into its architecture and key concepts!","timestamp":"2025-03-14 01:26:37","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1741944106846_apache_cassandra.png","image_alt":"Apache Cassandra","slug":"Apache-Cassandra-The-NoSQL-Powerhouse","index":"6b86b273ff34f","tags":["NO SQL","Data"]},{"blog_id":"f24fa0d0-6b50-494c-ab4d-49d1b302359f","title":"Building a Robust Microservices Architecture: From gRPC to Kubernetes","short_description":"In the ever-evolving world of software architecture, building a robust and scalable system is key to meeting the demands of modern applications. Recently, I had the opportunity to explore a powerful combination of technologies, starting with gRPC, translating it into HTTP/1.1, and finally deploying the system to a Kubernetes cluster. In this blog, I will take you through the journey, share the challenges I encountered, and explain why each of these steps is important for modern software systems.","timestamp":"2024-12-25 23:34:04","image":"https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2Fgrpc%20with%20kubernetes.png?alt=media&token=ae61e7f8-2088-416f-924c-512461e18206","image_alt":"Kubernetes+GRPC Background","slug":"Building-a-Robust-Microservices-Architecture-From-gRPC-to-Kubernetes","index":"6b86b273ff34f","tags":["Backend","Software Architecture","System Design","Node.Js","Docker","Cloud Computing"]},{"blog_id":"3b169c47-8359-4743-9dd2-eebbb68e0c52","title":"Building a Video Streaming Platform with AWS S3, HLS, and Node.js","short_description":"Ever wondered how your favorite streaming platforms deliver smooth, high-quality videos? Streaming video content is a cornerstone of modern web applications. Let’s explore how to build a video streaming service step by step.","timestamp":"2024-12-15 02:42:44","image":"https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2FHLS-IMAGE.jpg?alt=media&token=8077c433-3d64-4627-86d5-e9605a6aa9a2","image_alt":"HLS background","slug":"Building-a-Video-Streaming-Platform-with-AWS-S3-HLS-and-Nodejs","index":"6b86b273ff34f","tags":["Storage","API","Node.Js","Cloud Computing"]}]},"__N_SSG":true}