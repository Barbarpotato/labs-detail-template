{"pageProps":{"article":{"blog_id":"0e1dd5fa-3510-411f-9dc9-85938efe6af9","title":"Working with Time & Space Complexity ","short_description":"In this reading, We will explore a worked example of a piece of code written in Python, along with how you would evaluate it using Big-O notation.","description":"<div id=\"content-1\"><h2>Big-O notation</h2><p><br></p><p>Evaluating an application's performance ensures that the code written is good and fit for purpose. The question is how do we evaluate efficiency? When we measure electricity, we use kilowatt-hours, which means how many kilowatts an appliance will use if it runs for an hour. The appliance will not always run for an hour, and it may have different requirements depending on the setting used, it is more of a general rule-of-thumb for evaluating cost.</p><p>When evaluating coding solutions, Big-O notation is used. So, Big-O notation is the kilowatt hour of code evaluation. It can be applied to measuring how much time a piece of code will take or how much space it will use in memory. Not all processors will run at the same speed, so instead of timing an application, you count the number of instructions an application initiates.</p><p>Which measurement reflects the quickest possible execution of some code? Let's explore which measurement reflects the quickest possible execution of some code.</p><p><code style=\"background-color: var(--bgColor-neutral-muted, var(--color-neutral-muted));\">O(1)</code>&nbsp;You use a constant time algorithm that takes O(1) (O-of-one) time to compute. This determines that it will only take one computation to complete a task. An example of this is to print an item from an array.</p></div><div id=\"content-2\"><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\"># An array with 5 numbers \narray = [0,1,2,3,4]\n\n# retrieve the number found at index location 3 \nprint(array[3]) </code></pre></div><div id=\"content-3\"><p>In this instance, no matter how many values exist in the array, the approach has a Big-O of one. This means that running this code is considered O(1).</p><p><code style=\"background-color: var(--bgColor-neutral-muted, var(--color-neutral-muted));\">O(n)</code>&nbsp;Next, let's explore an example of O(n). Taking the same array, an if statement is written that looks for the number 5. To establish that 5 is not there, it has to check every item in the array.</p></div><div id=\"content-4\"><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\"># An array with 5 numbers \narray = [0,1,2,3,4] \n\nif 5 in array:\n    print(\"five is alive\")</code></pre></div><div id=\"content-5\"><p></p></div><div id=\"content-7\"><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\"># an array with 10 numbers \narray = [0,1,2,3,4,6,7,8,9,10]\n\nif 5 in array:\n    print(\"five is still alive\")</code></pre></div><div id=\"content-8\"><p><code style=\"background-color: var(--bgColor-neutral-muted, var(--color-neutral-muted));\">O(log n)</code>&nbsp;This search is less intensive than O(n) but more work than O(1). O(log n) is a logarithmic search and it will increase as new inputs are added but these inputs only offer marginal increases. An excellent example of this in action is a binary search. Binary search is covered in more detail later in the course.</p><p>Now, imagine playing a guessing game with the following prompts: too high, too low, or correct. You are given a range of 100 to 1. You may decide to approach the problem systematically. First, you guess 50 – too high. So, you guess 25 – which is too high. You may choose then to go 12 or 13. What is happening here is that you are halving the search space with each guess.</p><p>So, while the input to this function was 100 using a binary search approach, you should come upon the answer in under 5 or 6 guesses. This solution would have a time complexity of O(log n). Even if n (the range of numbers entered) is ten times bigger. It will not take ten times as many guesses.</p><p>Here is a breakdown of those steps on the array.</p></div><div id=\"content-9\"><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\">array = [0,1,2,3,4,6,7,8,9,10]\n\nprint(\"##Step One\")\nprint(\"Array\")\nprint(array)\nmidpoint = int(len(array)/2)\nprint(\"the midpoint at step one is: \" , array[midpoint])\n\nprint()\n\nprint(\"##Step Two\")\narray = array[:midpoint] # 6 is the midpoint of the array \nprint(\"Array\")\nprint(array)\n# running this shows the numbers left to check \n# is 5 &lt; 3 \n# no \n# so discard the left hand side \n\n# so the array is halved again \nmidpoint=int(len(array)/2)\nprint(\"the midpoint is: \",  array[midpoint])\n\nprint()\nprint(\"##Step Three\") \narray = array[midpoint:] # so the array is halved at the midpoint\nprint(array)# check for the midpoint \nmidpoint=int(len(array)/2)\nprint(\"the midpoint is: \" , array[midpoint])\n# is 4 &lt; 5 \n# yes look to the right\n\nprint()\nprint(\"##Step Four\") \nprint(array[midpoint:]) \n# check for the midpoint \narray = array[midpoint:] # so the array is halved at the midpoint\nmidpoint=int(len(array)/2)\n\n\n\nprint()\nprint(\"##Step Five\") \narray = array[midpoint:] \nprint(array)\nprint(\"only one value to check and it is not 5\")</code></pre></div><div id=\"content-10\"><p>You will notice that to determine if 5 is present, it took 5 steps. That is a big-O score of O(5). You can see that this is bigger than O(1) but smaller than O(n). Now, what happens when the array is extended to 100? When looking for a number in an array of 10, it took 5 guesses. Looking at an array of 100 will not take 50 guesses; it will take no more than 10. Equally, if the list is extended to 1000, the guesses will only go up to 15-20.</p><p>From this, we can see that it is not O(1) because the answer is not immediate. It is not big-O(n) because the number of guesses does not go up with the size n of the array. So here, one says that the complexity is O(log(n)).</p><p>To gain greater insight into how the log values are only a gradual rise, look at a log table up to 100,000,000. This lens shows that O(log n) incurs only a minimal processing cost. Running a binary search on an array with any n values will, in a worst-case scenario, always make the number of computations found in the log values column.</p><p><code style=\"background-color: var(--bgColor-neutral-muted, var(--color-neutral-muted));\">O(n^2)</code>&nbsp;is heavy on computation. This is quadratic complexity, meaning that the work is doubled for every element in the array. An excellent way to visualize this is to consider that you have a variety of arrays. In keeping with the earlier example, let's explore the following code:</p></div><div id=\"content-11\"><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\">new_array=[] # an array to hold all of the results \n# array with five numbers \narray = [0,1,2,3,4]\nfor i in range(len(array)): # the array has five values, so this is n=5 \n    for j in range(len(array)): # still the same array so n = 5 \n        new_array.append(i*j) # every computation made is stored here \n\nprint(len(new_array)) #how big is this new array ? </code></pre></div><div id=\"content-12\"><p>The first loop wi ll equal the number of elements input, n. The second loop will also look at the number of input elements, n. So, the overall complexity of running this approach can be said to be n*n which is n^2 (n-squared). To find out how many computations were made, you have to print out the number of times n was used in the loop as below.</p><p>If you know that the array has 25 elements, then you understand the principles of calculating Big-O notation. To further test your knowledge, how many computations would be required if n = 6? Meaning the array had 6 values? The answer is 6 x 6 so 36.</p></div><div id=\"content-13\"><h1>Working with Space Complexity</h1><p><br></p><p>Some Algorithms like&nbsp;<code style=\"background-color: var(--bgColor-neutral-muted, var(--color-neutral-muted));\">hash tables</code>&nbsp;provide very fast lookups in&nbsp;<code style=\"background-color: var(--bgColor-neutral-muted, var(--color-neutral-muted));\">O(10) time</code>. However, to work efficiently, they must have a lookup every element stored. This results in a space complexity of O(n). The big O-notation for space complexity is the same as for the time O(1), O(log log n), O(log n) and so on. In all these notations&nbsp;<code style=\"background-color: var(--bgColor-neutral-muted, var(--color-neutral-muted));\">n</code>&nbsp;refers to the size of the input. This is often measured in bytes.</p><p>Different languages have different memory costs associated with them. In java for instance, an integer requires 4 bytes of memory. A blank array will consume 12 bytes for the header object and an additional 4 bytes for padding. Thus, if n refers to an array of integers size 4, then the total memory requirement is 32 bytes of memory.&nbsp;<code style=\"background-color: var(--bgColor-neutral-muted, var(--color-neutral-muted));\">(4 * 4) + 12 + 4 = 32</code></p><p>When discussing space complexity, you have to consider what the increase in input size has on the overall usage. Space Compexity is the total of auxiliary space + input space The space complexity of a problem can be broken into two sections namely auxiliary and input space:</p><ul><li>Auxiliary space is the space required to hold all data required for the solution. It refers to the temporary space needed to compute a given solution.</li><li>Input space refers to the space required to add data to the function, algorithm, application or system that you are evaluating.</li></ul></div><div id=\"content-14\"><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\">const a = 1;\nconst b = 10;\nconst c = 100;\nconst sum = (a, b, c) =&gt; a + b + c;\nconst d = sum(a, b, c);</code></pre></div><div id=\"content-15\"><p>In the above function sum, we can resolve the space complexity required by the memory requirement. Given that all arguments in the above example are integers and the return value is an integer of set size, we know this will be constant.</p><p>Given the Number type in JavaScript is 64-bit (8 bytes), we can resolve that the memory requirement for a, b and c is (24). Therefore, the function sum has&nbsp;<code style=\"background-color: var(--bgColor-neutral-muted, var(--color-neutral-muted));\">O(1)</code>&nbsp;constant space complexity given that we know the constant requirement of 24 bytes of data space for this function.</p><p>Looking at an example in C that requires a dynamic amount of memory in an array:</p></div><div id=\"content-16\"><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\">int sum(int a[], int n) {\n    int x = 0;      // 4 bytes for x\n    for(int i = 0; i &lt; n; i++)  // 4 bytes for i\n    {\n        x  = x + a[i];\n    }\n    return(x);\n}</code></pre></div><div id=\"content-17\"><p>Firstly, we know that int types in C require 4 bytes of space. Here we note that 4*n bytes of space is required for the array a[] of integers. The remaining variables x, n, i and the return value each require a constant 4 bytes each of memory give that they are integers.</p><p>This gives us a total memory requirement of (4n + 12). This itself is&nbsp;<code style=\"background-color: var(--bgColor-neutral-muted, var(--color-neutral-muted));\">O(n)</code>&nbsp;linear space complexity since the memory requires linearly increases with input value n.</p><p>What is important to note with this example is that the auxiliary space required for the above sum function is actually&nbsp;<code style=\"background-color: var(--bgColor-neutral-muted, var(--color-neutral-muted));\">O(1)</code>&nbsp;constant given that the auxiliary variables are only x and i which totals a (8) memory requirement (constant).</p></div>","timestamp":"Friday, September 20, 2024 at 11:35:52 AM GMT+8","image":"https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2Fcoding_interview.png?alt=media&token=1e7a8927-e196-4b59-a0bd-202c9d190484","image_alt":"Coding interview Preparation","slug":"working-with-time--space-complexity-","index":"6b86b273ff34f","tags":["Algorithm"]},"recommendedPosts":[]},"__N_SSG":true}