{"pageProps":{"article":{"blog_id":"978cd40e-18da-47a6-a4fe-917bec69dea1","title":"React Lazy Load","short_description":"React Lazy Load is a technique used to load React components lazily, i.e., only when they are needed. This helps reduce the initial bundle size and improve the performance of your React application. You can easily implement lazy loading in your React project using React.lazy() along with Suspense.","description":"<div id=\"content-0\"><h1><strong>Real-World Case</strong></h1></div><div id=\"content-1\"><img style='width:720px;' src='https://raw.githubusercontent.com/Barbarpotato/React-Lazy-Load/main/git-image/Scenario.png'/></div><div id=\"content-2\"><p>When building a dashboard application. This application has high complexity and requires a large size to be loaded by application users in the future. For example, the dashboard application has several different features, depending on the position of each application user. for example, users with the admin position have a different features in the application compared to users with other positions, for example Sales. When Sales enters a dashboard application. Of course, the features contained in admin will not appear for users with sales positions, BUT users with sales positions will still load the features contained in admin even though they are not used. Vice Versa, This affects the performance, speed and efficiency of an application running.</p><p><br></p><h2><strong>Solution</strong></h2><p>To asnwer the prbolem above, we will be use&nbsp;<code style=\"color: rgb(248, 248, 242); background-color: var(--bgColor-neutral-muted, var(--color-neutral-muted));\">Lazy Load</code>&nbsp;technique, you can optimize the initial loading time and improve the performance of your React application by dynamically loading components as needed.</p><h2><strong>Usage</strong></h2><p>Here are the steps on how to use React Lazy Load in your project:</p><h3><strong>Create the routes for the web page.</strong></h3><p>We have 3 different pags for this case, Main page which can be access for all the role position (Admin, Sales). we have the sales component which can be access by sales person, and the last page is the admin page, where it can only be access by the admin person.</p></div><div id=\"content-3\"><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\">import { Routes, Route } from 'react-router-dom'\nimport Sales from './pages/Sales'\nimport Home from './pages/Home'\nimport Admin from './pages/Admin'\nimport './App.css'\n\nfunction App() {\n\n  return (\n    &lt;Routes&gt;\n      &lt;Route index element={&lt;Home /&gt;} /&gt;\n      &lt;Route path='/sales' element={&lt;Sales /&gt;} /&gt;\n      &lt;Route path='/admin' element={&lt;Admin /&gt;} /&gt;\n    &lt;/Routes&gt;\n  )\n}\n\nexport default App</code></pre></div><div id=\"content-6\"><p>If we dont implement the lazy load technique&nbsp;&nbsp;our react application&nbsp;it will be load&nbsp;&nbsp;three pages&nbsp;which are Main, Sales&nbsp;&nbsp;the Admin page. If we implement the lazy load, whenever we access the Sales Page, it will be load the Main&nbsp;&nbsp;the Sales Page, Vice Versa</p><h2>Applied the Lazy Load to your React App</h2><p>After build the different page&nbsp;&nbsp;route, we can implement the lazy load by using the lazy&nbsp;&nbsp;Suspense</p></div><div id=\"content-7\"><pre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"><code style=\"color: white;\">import { Routes, Route } from 'react-router-dom'\nimport { lazy, Suspense } from 'react'\nimport Home from './pages/Home'\nimport './App.css'\n\nconst Admin = lazy(() =&gt; import('./pages/Admin'))\nconst Sales = lazy(() =&gt; import('./pages/Sales'))\n\nfunction App() {\n\n  return (\n    &lt;Routes&gt;\n\n      &lt;Route index element={&lt;Home /&gt;} /&gt;\n\n      &lt;Route path='/sales' element={\n        &lt;Suspense fallback={&lt;div&gt;Loading Content...&lt;/div&gt;}&gt;\n          &lt;Sales /&gt;\n        &lt;/Suspense&gt;} /&gt;\n\n      &lt;Route path='/admin' element={\n        &lt;Suspense fallback={&lt;div&gt;Loading Content...&lt;/div&gt;}&gt;\n          &lt;Admin /&gt;\n        &lt;/Suspense&gt;} /&gt;\n\n    &lt;/Routes &gt;\n  )\n}\n\nexport default App</code></pre></div><div id=\"content-8\"><h2><strong>Implementation Result</strong></h2><p>Now, if you go to the Dev Console -&gt; Source. You need to check the page source file. and then check the src folder -&gt; pages . We cannot see our Admin and Sales Component. If we accessing the admin route or the sales route, it will appear in the source dev console. which means that our lazy load implement successfully.</p></div><div id=\"content-10\"><img style='width:720px;' src='https://raw.githubusercontent.com/Barbarpotato/React-Lazy-Load/main/git-image/lazy-load.png'/></div>","timestamp":"Friday, September 20, 2024 at 11:36:59 AM GMT+8","image":"https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2Flazy-load.png?alt=media&token=94d1a55f-c578-455a-9623-b561272a9f99","image_alt":"Lazy Load React - Darma","slug":"react-lazy-load","index":"6b86b273ff34f","tags":["React.js","Frontend"]},"recommendedPosts":[{"blog_id":"e7d3943c-c12a-42c1-9663-2d90449138dc","title":"The concept of splitting a frontend into smaller, manageable pieces.","short_description":"Have you ever worked on a massive frontend application where every change felt risky and deploying updates took ages? If so, micro frontends might be the solution youâ€™ve been looking for","timestamp":"2024-12-04 03:23:45","image":"https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2Fmicrofrontend.webp?alt=media&token=6274c176-9622-4cd5-93be-9ea9e5912bd9","image_alt":"Microfrontend Image Cover","slug":"the-concept-of-splitting-a-frontend-into-smaller-manageable-pieces","index":"6b86b273ff34f","tags":["Frontend","Software Architecture","System Design"]},{"blog_id":"4a5ae2d7-0f8f-46b9-b49a-4ff130f22292","title":"Why You Need Kubernetes: A Comprehensive Guide","short_description":"In today's fast-paced digital landscape, applications are becoming increasingly complex and distributed. To manage this complexity and ensure high availability, reliability, and scalability, organizations are turning to Kubernetes. This powerful container orchestration platform has revolutionized the way we deploy and manage applications.","timestamp":"2024-11-02 15:48:06","image":"https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2FKubernetes-logo-1024x576.png?alt=media&token=e6f56ef1-e429-4d8f-9597-2d5a01023cf9","image_alt":"Kubernetes Logo","slug":"why-you-need-kubernetes-a-comprehensive-guide","index":"6b86b273ff34f","tags":["System Design","Software Architecture","Frontend"]},{"blog_id":"7a76b44a-8bc3-451e-95f0-3ccb1bc23e34","title":"Create Dashboard app with Electron.js","short_description":"In the world of application development, Electron.js has become a popular framework for building desktop applications using web technologies. In this blog, we will discuss how to create a desktop application template with Electron.js using React and Vite as the frontend framework, and IndexedDB as the default client-side database.","timestamp":"2024-09-20 06:06:27","image":"https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2Felectron.png?alt=media&token=46d654ee-c016-41d2-ab1d-38d5653638a6","image_alt":"Electron.js","slug":"create-dashboard-app-with-electronjs","index":"6b86b273ff34f","tags":["Frontend","Application"]}]},"__N_SSG":true}