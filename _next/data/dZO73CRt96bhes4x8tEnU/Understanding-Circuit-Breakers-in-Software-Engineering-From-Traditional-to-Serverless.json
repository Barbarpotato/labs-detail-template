{"pageProps":{"article":{"blog_id":"86f7440f-033f-4459-b0a5-09f74d7c34ba","title":"Understanding Circuit Breakers in Software Engineering: From Traditional to Serverless","short_description":"Imagine you’re using electricity at home, and a short circuit occurs. The circuit breaker in your electrical panel cuts the power to prevent a fire. In software, the concept is similar: it’s a design pattern that protects your system from repeated failures when calling external services","description":"<h2>What Is a Circuit Breaker?</h2><p>Imagine you’re using electricity at home, and a short circuit occurs. The <em>circuit breaker</em> in your electrical panel cuts the power to prevent a fire. In software, the concept is similar: it’s a design pattern that protects your system from repeated failures when calling external services (APIs, databases, etc.).</p><h2>Main Purposes:</h2><h3><strong>Detect Failures</strong></h3><p>The first job of a <em>circuit breaker</em> is to act as a vigilant watchdog, constantly monitoring interactions between your application and external services like APIs, databases, or third-party systems. It keeps an eye on every request, tracking whether they succeed or fail based on specific criteria, such as receiving an error code (e.g., HTTP 500), timing out after a set duration (e.g., no response within 2 seconds), or encountering exceptions like network disconnections.</p><p>To do this effectively, the circuit breaker collects data over a defined window—perhaps the last 10 requests or the past 30 seconds—and calculates metrics like the total number of failures or the failure rate (e.g., 60% of calls failed). If these metrics cross a configurable threshold—say, five failures in a row or a 50% error rate—it recognizes that something’s wrong with the external service. This detection isn’t just about noticing a single hiccup; it’s about identifying patterns of unreliability that could harm your system if left unchecked. By catching these issues early, the circuit breaker ensures your application doesn’t blindly keep trying a service that’s clearly struggling.</p><h3><strong>Prevent Cascading Failures</strong></h3><p>Once a failure is detected, the circuit breaker steps in to stop a domino effect known as <em>cascading failures</em>, where one broken component drags down the entire system. Imagine an e-commerce app where the payment API is down: without a circuit breaker, every user request might hang, waiting for a timeout, piling up server resources, slowing the database, and eventually crashing the whole application.</p><p>In its Closed state, the circuit breaker allows calls to proceed, but as soon as failures hit the threshold, it flips to Open, cutting off all further attempts to contact the faulty service. This immediate halt prevents the problem from rippling through your system—your app stops wasting threads, memory, or CPU cycles on a hopeless task. Instead of letting a single point of failure—like a slow third-party API—overload your servers or exhaust connection pools, the circuit breaker isolates the issue, keeping the rest of your application stable and responsive. It’s like closing a floodgate to protect the town downstream from a burst dam.</p><h3><strong>Provide a Fallback Response</strong></h3><p>When the circuit breaker blocks calls in its Open state, it doesn’t just leave users hanging—it offers a fallback response to keep the system usable. This fallback is a preplanned alternative to the failed service’s output, designed to minimize disruption.</p><p>For example, if a weather API fails, the circuit breaker might return a cached forecast from an hour ago or a simple message like \"Weather data unavailable, try again later.\" In a payment system, it could redirect users to an alternative checkout method or log the attempt for later retry. The fallback doesn’t fix the root problem, but it ensures graceful degradation.</p><p>Your application keeps running in a limited capacity rather than crashing or showing cryptic errors. Crafting a good fallback requires understanding your use case: it might be static data, a default value, or even a call to a backup service. By providing this safety net, the circuit breaker maintains user trust and buys time for the external service to recover without sacrificing functionality entirely.</p><p><img src=\"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1741949039277_Circuit-Breaker-Pattern.jpg\" alt=\"Circuit Breaker Pattern\" width=\"720px\"></p><h2>Overall Mechanism</h2><ol><li><strong>Closed</strong>: All calls are forwarded. If failures exceed the threshold (e.g., 5), it switches to Open.</li><li><strong>Open</strong>: Calls are blocked, and a <em>fallback</em> is used. After a set time (e.g., 30 seconds), it moves to Half-Open.</li><li><strong>Half-Open</strong>: A test call is made. Success → Closed, Failure → Open.</li></ol><h3>Simple Code Example</h3><p>Here’s a basic implementation in JavaScript:</p><div><pre><code>class CircuitBreaker {\n&nbsp; constructor(maxFailures = 5, resetTimeout = 30000) {\n&nbsp; &nbsp; this.state = \"CLOSED\";\n&nbsp; &nbsp; this.failureCount = 0;\n&nbsp; &nbsp; this.maxFailures = maxFailures;\n&nbsp; &nbsp; this.resetTimeout = resetTimeout;\n&nbsp; }\n\n\n&nbsp; async call(service) {\n&nbsp; &nbsp; if (this.state === \"OPEN\") {\n&nbsp; &nbsp; &nbsp; if (Date.now() &gt; this.resetTime) {\n&nbsp; &nbsp; &nbsp; &nbsp; this.state = \"HALF_OPEN\";\n&nbsp; &nbsp; &nbsp; } else {\n&nbsp; &nbsp; &nbsp; &nbsp; return \"Fallback: Service unavailable\";\n&nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n\n\n&nbsp; &nbsp; try {\n&nbsp; &nbsp; &nbsp; const result = await service();\n&nbsp; &nbsp; &nbsp; if (this.state === \"HALF_OPEN\") {\n&nbsp; &nbsp; &nbsp; &nbsp; this.state = \"CLOSED\";\n&nbsp; &nbsp; &nbsp; &nbsp; this.failureCount = 0;\n&nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; return result;\n&nbsp; &nbsp; } catch (error) {\n&nbsp; &nbsp; &nbsp; this.failureCount++;\n&nbsp; &nbsp; &nbsp; if (this.failureCount &gt;= this.maxFailures) {\n&nbsp; &nbsp; &nbsp; &nbsp; this.state = \"OPEN\";\n&nbsp; &nbsp; &nbsp; &nbsp; this.resetTime = Date.now() + this.resetTimeout;\n&nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; return \"Fallback: Service unavailable\";\n&nbsp; &nbsp; }\n&nbsp; }\n}\n\n\n// Example usage\nconst breaker = new CircuitBreaker();\nconst fakeService = () =&gt; Math.random() &gt; 0.5 ? \"Success\" : Promise.reject(\"Error\");\nbreaker.call(fakeService).then(console.log);\n</code></pre></div><h2>Circuit Breakers in Serverless</h2><p>In a <em>serverless</em> environment (e.g., AWS Lambda), <em>circuit breakers</em> are still valuable, but their stateless nature poses challenges. The state must be stored externally, such as in DynamoDB.</p><h3>Example in AWS Lambda</h3><div><pre><code>const AWS = require('aws-sdk');\nconst dynamodb = new AWS.DynamoDB.DocumentClient();\n\n\nasync function handler(event) {\n&nbsp; const serviceName = \"ExternalAPI\";\n&nbsp; const state = await dynamodb.get({\n&nbsp; &nbsp; TableName: \"CircuitBreakerState\",\n&nbsp; &nbsp; Key: { Service: serviceName }\n&nbsp; }).promise();\n\n\n&nbsp; if (state.Item?.State === \"OPEN\" &amp;&amp; Date.now() &lt; state.Item.ResetTime) {\n&nbsp; &nbsp; return { statusCode: 503, body: \"Service unavailable\" };\n&nbsp; }\n\n\n&nbsp; try {\n&nbsp; &nbsp; const response = await callExternalAPI();\n&nbsp; &nbsp; if (state.Item?.State === \"HALF_OPEN\") {\n&nbsp; &nbsp; &nbsp; await dynamodb.update({\n&nbsp; &nbsp; &nbsp; &nbsp; TableName: \"CircuitBreakerState\",\n&nbsp; &nbsp; &nbsp; &nbsp; Key: { Service: serviceName },\n&nbsp; &nbsp; &nbsp; &nbsp; UpdateExpression: \"SET #state = :closed\",\n&nbsp; &nbsp; &nbsp; &nbsp; ExpressionAttributeNames: { \"#state\": \"State\" },\n&nbsp; &nbsp; &nbsp; &nbsp; ExpressionAttributeValues: { \":closed\": \"CLOSED\" }\n&nbsp; &nbsp; &nbsp; }).promise();\n&nbsp; &nbsp; }\n&nbsp; &nbsp; return { statusCode: 200, body: response };\n&nbsp; } catch (error) {\n&nbsp; &nbsp; // Logic to update failure count and switch to Open\n&nbsp; &nbsp; return { statusCode: 503, body: \"Service unavailable\" };\n&nbsp; }\n}\n</code></pre></div><h2>Conclusion</h2><p><em>Circuit breakers</em> are a powerful pattern for building resilient systems, whether on traditional servers or in <em>serverless</em> environments. With the simulations and code above, I hope you’ve gained a clearer understanding of how they work.</p>","timestamp":"Friday, March 14, 2025 at 10:46:27 AM GMT+8","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1741948558177_circuit_breaker.png","image_alt":"Circuit breaker","slug":"Understanding-Circuit-Breakers-in-Software-Engineering-From-Traditional-to-Serverless","index":"6b86b273ff34f","tags":["System Design","Software Architecture"]},"recommendedPosts":[{"blog_id":"4400b3a0-4d34-4185-806a-f265089e8af8","title":"MySQL Migration with Connection Pooling: A Simple Guide","short_description":"Imagine standing in line at a coffee shop where each customer needs to fill out a membership form before ordering and then tears it up after getting their coffee. Sounds inefficient, right? This is exactly what happens when your application connects to a database without connection pooling.","timestamp":"2025-04-28 11:49:06","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1745838714722_connection%20pool%20Bg.png","image_alt":"Connection Pool Labs Content","slug":"MySQL-Migration-with-Connection-Pooling-A-Simple-Guide-1","index":"d4735e3a265e1","tags":["System Design","Database","Software Architecture","Cloud Computing"]},{"blog_id":"6234fef8-1547-46f7-ae10-33d577a1d168","title":"Understanding RabbitMQ: A Favorite Simple Messaging Service!","short_description":"RabbitMQ is a robust, open-source message broker that facilitates communication between applications by sending and receiving messages. Whether you're building a microservices architecture or a distributed system, RabbitMQ ensures reliable, scalable, and asynchronous messaging. In this blog, we’ll walk through its core components and concepts, from producers to consumers, and dive into some advanced features like round-robin dispatching and virtual hosts.","timestamp":"2025-03-15 19:44:13","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1742090540692_rabbitmq.webp","image_alt":"rabbit mq","slug":"Understanding-RabbitMQ-A-Favorite-Simple-Messaging-Service","index":"6b86b273ff34f","tags":["Message Broker","System Design","Software Architecture"]},{"blog_id":"911a9001-3c3e-4f2c-aa83-4ec4f6f71c99","title":"Terraform Labs: Automating Google Cloud Infrastructure Deployment","short_description":"Manually managing cloud infrastructure can be time-consuming and error-prone. Terraform changes the game by allowing you to define infrastructure as code, making deployment faster, scalable, and repeatable. With Terraform, you can automate cloud resource creation, track changes, and collaborate effortlessly.","timestamp":"2025-02-15 18:15:22","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1739669992396_gcp-terraform.png","image_alt":"Terraform with GCP","slug":"Terraform-Labs-Automating-Google-Cloud-Infrastructure-Deployment","index":"6b86b273ff34f","tags":["Software Architecture","Cloud Computing"]}]},"__N_SSG":true}